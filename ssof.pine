// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© SSOF - Smart Structure & Order Flow
// GitHub: https://github.com/d1360tx/tradingview-ssof-indicator

//@version=6
indicator("Smart Structure & Order Flow [SSOF] V7.4.0-beta (Momentum + Partial Exits)", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ INPUTS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Auto-Timeframe Settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpAutoTF = "ğŸ• Auto-Timeframe Adjustment"
useAutoTF = input.bool(true, "Enable Auto Timeframe Adjustment?", group=grpAutoTF, tooltip="Automatically adjust swing length based on current timeframe")
tf1m = input.int(3, "1m Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf5m = input.int(5, "5m Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf15m = input.int(7, "15m Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf30m = input.int(5, "30m Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf1h = input.int(10, "1H Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf4h = input.int(15, "4H Swing Length", minval=1, maxval=50, group=grpAutoTF)
tfD = input.int(20, "Daily Swing Length", minval=1, maxval=50, group=grpAutoTF)
tfW = input.int(25, "Weekly Swing Length", minval=1, maxval=50, group=grpAutoTF)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Structure Settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpStructure = "âš™ï¸ Structure Settings"
manualSwingLength = input.int(5, "Manual Swing Length", minval=1, maxval=50, group=grpStructure, tooltip="Used when Auto-TF is disabled")
showInternalStructure = input.bool(false, "Show Internal Structure?", group=grpStructure, tooltip="Show minor pivots within the major trend")
internalLength = input.int(3, "Internal Lookback Length", minval=1, maxval=20, group=grpStructure, tooltip="Lookback for internal structure pivots")
showLiqSweeps = input.bool(true, "Show Liquidity Sweeps?", group=grpStructure, tooltip="Mark when price sweeps a level but closes back inside")
showDevelopingLevels = input.bool(true, "Show Developing BOS Levels?", group=grpStructure, tooltip="Show dashed lines at swing levels before BOS confirmation")
showZigZag = input.bool(true, "Show Zig-Zag Path?", group=grpStructure, tooltip="Connect swing points with trend-colored lines")
maxZigZagLines = input.int(50, "Max Zig-Zag Lines", minval=1, maxval=100, group=grpStructure, tooltip="Number of recent zig-zag connections to display")
showLabels = input.bool(true, "Show HH/HL/LH/LL Labels?", group=grpStructure)
showDashboard = input.bool(true, "Show Trend Dashboard?", group=grpStructure)
dashboardPosition = input.string("Top Right", "Dashboard Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group=grpStructure)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Protected Levels (A4) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpProtected = "ğŸ›¡ï¸ Protected Levels (Structure Anchors)"
useProtectedLevels = input.bool(true, "Enable Protected Levels?", group=grpProtected, tooltip="Structure only invalidates when protected level breaks, not every swing")
protectedLookback = input.int(2, "Protected Level Lookback (x Swing Length)", minval=1, maxval=5, group=grpProtected, tooltip="Multiplier of swing length to find origin low/high")
showProtectedLines = input.bool(true, "Show Protected Level Lines?", group=grpProtected, tooltip="Draw horizontal lines at protected levels")
protectedLineStyle = input.string("Dashed", "Protected Line Style", options=["Solid", "Dashed", "Dotted"], group=grpProtected)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal Structure Filter (A5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpInternal = "ğŸ” Internal Structure Filter"
useInternalFilter = input.bool(true, "Filter Internal Breaks?", group=grpInternal, tooltip="Ignore breaks that happen inside the last impulse range")
showInternalBreaks = input.bool(false, "Show Internal Break Labels?", group=grpInternal, tooltip="Mark internal breaks that don't flip trend")
showTrapWarnings = input.bool(true, "Show Trap Warnings?", group=grpInternal, tooltip="Alert when price breaks internal level but stays in range")
showInternalZones = input.bool(false, "Show Internal Structure Zones?", group=grpInternal, tooltip="Create supply/demand zones at internal breaks (dimmer styling). Useful for reference but not true BOS zones.")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Consolidation Detection (A1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpConsolidation = "ğŸ“Š Consolidation Detection"
useConsolidation = input.bool(true, "Enable Consolidation Detection?", group=grpConsolidation, tooltip="Detect when market is range-bound")
consolidationBars = input.int(8, "Lookback Bars", minval=3, maxval=20, group=grpConsolidation, tooltip="Number of bars to analyze for consolidation range")
consolidationRangeATR = input.float(2.5, "Max Range (ATR)", minval=0.3, maxval=5.0, step=0.1, group=grpConsolidation, tooltip="Maximum range size as ATR multiple to qualify as consolidation")
minConsolidationBars = input.int(6, "Minimum Duration (bars)", minval=3, maxval=20, group=grpConsolidation, tooltip="Minimum bars price must stay in range to qualify as consolidation")
showConsolidationBox = input.bool(true, "Show Consolidation Range Box?", group=grpConsolidation, tooltip="Draw a box around the consolidation range")
showHistoricalConsolidation = input.bool(true, "Show Historical Consolidation?", group=grpConsolidation, tooltip="Keep broken consolidation zones visible (dimmed)")
maxHistoricalBoxes = input.int(5, "Max Historical Boxes", minval=1, maxval=20, group=grpConsolidation, tooltip="Number of historical consolidation boxes to keep")
consolidationColor = input.color(color.rgb(128, 128, 128, 80), "Consolidation Box Color", group=grpConsolidation)
brokenConsolidationColor = input.color(color.rgb(100, 100, 100, 90), "Broken Consolidation Color", group=grpConsolidation)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Displacement Strength (A6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpDisplacement = "ğŸ’ª Displacement Strength (BOS Quality)"
useDisplacementGrading = input.bool(true, "Grade BOS Strength?", group=grpDisplacement, tooltip="Classify BOS as Strong or Weak based on candle characteristics")
strongBOSThreshold = input.float(0.5, "Strong BOS (Body/ATR Ratio)", minval=0.1, maxval=2.0, step=0.1, group=grpDisplacement, tooltip="Body must be > this % of ATR to be strong")
showStrengthLabels = input.bool(true, "Show Strength on BOS Labels?", group=grpDisplacement, tooltip="Add (S) or (W) suffix to BOS labels")
atrPeriod = input.int(14, "ATR Period", minval=5, maxval=50, group=grpDisplacement)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Zone Settings (A7) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpZones = "ğŸ“¦ Supply & Demand Zones"
showZones = input.bool(true, "Show Supply/Demand Zones?", group=grpZones)
zoneDirectionFilter = input.bool(true, "Filter Zones by Trend?", group=grpZones, tooltip="Only show demand in bullish structure, supply in bearish")
requireFVG = input.bool(false, "Require Imbalance/FVG?", group=grpZones, tooltip="Only show zones that have FVG confirmation for higher probability")
fvgMinSize = input.float(0.5, "Min FVG Size (ATR %)", minval=0.1, maxval=5.0, step=0.1, group=grpZones, tooltip="Minimum FVG size as percentage of ATR")
removeMitigated = input.bool(true, "Remove Mitigated Zones?", group=grpZones, tooltip="Auto-delete zones that price breaks through")
zoneExtendBars = input.int(20, "Zone Extension (bars)", minval=5, maxval=100, group=grpZones)
maxZones = input.int(10, "Max Zones to Show", minval=3, maxval=50, group=grpZones)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Pullback Entry (Fib Golden Zone) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpPullback = "ğŸ“ Pullback Entry (Fib Golden Zone)"
showPullbackZone = input.bool(true, "Show Pullback Entry Zone?", group=grpPullback, tooltip="Draw fib retracement golden zone after BOS")
fibUpperLevel = input.float(0.5, "Fib Upper Level", minval=0.1, maxval=0.9, step=0.01, group=grpPullback, tooltip="Upper boundary of golden zone")
fibLowerLevel = input.float(0.618, "Fib Lower Level", minval=0.1, maxval=0.9, step=0.01, group=grpPullback, tooltip="Lower boundary of golden zone (deeper retracement)")
fibDeepLevel = input.float(0.786, "Fib Deep Level (Discount)", minval=0.5, maxval=0.95, step=0.01, group=grpPullback, tooltip="Deeper discount zone - higher risk/reward")
showDeepZone = input.bool(false, "Show Deep Discount Zone?", group=grpPullback, tooltip="Show the deeper 0.618-0.786 zone")
goldenZoneColorBull = input.color(color.rgb(255, 215, 0, 80), "Bullish Golden Zone Color", group=grpPullback)
goldenZoneColorBear = input.color(color.rgb(255, 140, 0, 80), "Bearish Golden Zone Color", group=grpPullback)
deepZoneColor = input.color(color.rgb(255, 100, 100, 85), "Deep Zone Color", group=grpPullback)
// V7.0: Removed useProtectedFibOrigin toggle - always use impulse range (impulseLow/impulseHigh)
// This ensures fibs anchor from the ACTIVE impulse leg, not old structure

// Confirmation settings
grpConfirmation = "âœ… Entry Confirmation"
confirmationType = input.string("Zone Breakout", "Confirmation Type", options=["None", "Displacement Candle", "Internal BOS", "Zone Breakout", "Zone Confluence", "Both"], group=grpConfirmation, tooltip="How to confirm pullback is ending:\nâ€¢ None: Immediate on zone entry\nâ€¢ Displacement: Strong candle in trend direction\nâ€¢ Internal BOS: Break internal swing\nâ€¢ Zone Breakout: Break back above 0.5 fib\nâ€¢ Zone Confluence: Price near demand/supply zone\nâ€¢ Both: All conditions")
displacementATR = input.float(0.5, "Displacement Candle (Body/ATR)", minval=0.2, maxval=1.5, step=0.1, group=grpConfirmation, tooltip="Minimum candle body size as ATR ratio for displacement confirmation")
requireZoneConfluence = input.bool(true, "Require Zone Confluence?", group=grpConfirmation, tooltip="Entry must occur near a demand/supply zone for higher probability")
zoneProximityATR = input.float(0.4, "Zone Proximity (ATR)", minval=0.1, maxval=1.0, step=0.1, group=grpConfirmation, tooltip="How close price must be to a zone to count as confluence")
minBarsInZone = input.int(2, "Min Bars in Golden Zone", minval=1, maxval=10, group=grpConfirmation, tooltip="Price must stay in zone for at least this many bars before entry")
showConfirmationSignal = input.bool(true, "Show Entry Signal?", group=grpConfirmation, tooltip="Show label when confirmation triggers in golden zone")
showFibLines = input.bool(true, "Show Fib Level Lines?", group=grpConfirmation, tooltip="Draw horizontal lines at key fib levels")

// Phase 1 Filters - High Impact
requireStrongBOS = input.bool(true, "Require Strong BOS?", group=grpConfirmation, tooltip="Only create entry zones after Strong (S) BOS - filters weak impulse moves")
requireSwingRespect = input.bool(true, "Require Swing Respect?", group=grpConfirmation, tooltip="Entry invalid if price touched protected level during pullback")
maxBarsForEntry = input.int(25, "Max Bars for Entry", minval=10, maxval=100, group=grpConfirmation, tooltip="Invalidate zone if no entry within this many bars (prevents stale signals)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Momentum Entry (Tier 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpMomentum = "âš¡ Momentum Entry"
enableMomentumEntry = input.bool(true, "Enable Momentum Entry?", group=grpMomentum, tooltip="Take immediate entry on BOS confirmation (before pullback)\nCaptures full impulse move at cost of wider stop")
momentumPositionSize = input.int(20, "Momentum Position Size %", minval=5, maxval=50, group=grpMomentum, tooltip="Percentage of full position to enter on momentum\nRecommended: 20% (leaves 80% for pullback entry)")
momentumRequireStrong = input.bool(true, "Require Strong BOS?", group=grpMomentum, tooltip="Only take momentum entry on Strong (S) BOS\nFilters weak/low-probability setups")
momentumMinDisplacement = input.float(0.7, "Min Displacement (Body/ATR)", minval=0.3, maxval=1.5, step=0.1, group=grpMomentum, tooltip="Minimum candle body size for momentum entry\nHigher = more aggressive BOS required")
showMomentumLabels = input.bool(true, "Show Momentum Entry Labels?", group=grpMomentum, tooltip="Display âš¡ ENTRY labels on momentum entries")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Partial Exits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpPartialExits = "ğŸ“Š Partial Exits"
enablePartialExits = input.bool(true, "Enable Partial Exits?", group=grpPartialExits, tooltip="Use 3-tier exit strategy instead of single exit\nT1: Quick profit, T2: Main target, T3: Runner")

// T1 Settings
t1PositionPct = input.int(30, "T1 Position %", minval=10, maxval=50, group=grpPartialExits, tooltip="Percentage to exit at first target")
t1TargetType = input.string("R:R Ratio", "T1 Target Type", options=["R:R Ratio", "First Swing"], group=grpPartialExits, tooltip="R:R Ratio: Fixed multiple of risk\nFirst Swing: Nearest swing high/low")
t1RRRatio = input.float(1.5, "T1 R:R Ratio", minval=1.0, maxval=3.0, step=0.1, group=grpPartialExits, tooltip="Risk:Reward ratio for T1 exit")

// T2 Settings
t2PositionPct = input.int(40, "T2 Position %", minval=20, maxval=60, group=grpPartialExits, tooltip="Percentage to exit at second target")
t2TargetType = input.string("BOS Swing", "T2 Target Type", options=["R:R Ratio", "BOS Swing"], group=grpPartialExits, tooltip="R:R Ratio: Fixed multiple\nBOS Swing: Dynamic structure target")
t2RRRatio = input.float(2.5, "T2 R:R Ratio", minval=1.5, maxval=5.0, step=0.1, group=grpPartialExits, tooltip="Risk:Reward ratio for T2 exit")

// T3 Settings
t3PositionPct = input.int(30, "T3 Position %", minval=10, maxval=50, group=grpPartialExits, tooltip="Percentage to exit at third target (runner)")
t3UseTrailStop = input.bool(true, "T3 Use Trail Stop?", group=grpPartialExits, tooltip="Trail stop below/above swing lows/highs for runner")
t3TrailMethod = input.string("Swing Levels", "T3 Trail Method", options=["Swing Levels", "ATR Distance"], group=grpPartialExits, tooltip="Swing Levels: Trail below HL/above LH\nATR Distance: Fixed ATR distance")
t3ATRMultiple = input.float(1.5, "T3 ATR Multiple", minval=0.5, maxval=3.0, step=0.1, group=grpPartialExits, tooltip="ATR multiple for trail stop if using ATR method")

// Partial Exit Visualization
showTargetLines = input.bool(true, "Show Target Lines?", group=grpPartialExits, tooltip="Draw horizontal lines at T1 and T2 targets")
showTrailStopLine = input.bool(true, "Show Trail Stop Line?", group=grpPartialExits, tooltip="Draw dynamic trail stop line for T3")

// Exit Signals
grpExit = "ğŸšª Exit Signals"
showExitSignals = input.bool(true, "Show Exit Signals?", group=grpExit, tooltip="Display exit signals when target reached or momentum lost")
exitOnSwingHigh = input.bool(true, "Exit at Prior Swing High/Low?", group=grpExit, tooltip="Exit when price reaches the swing point that preceded the BOS")
exitOnMomentumLoss = input.bool(true, "Exit on Momentum Loss?", group=grpExit, tooltip="Exit when strong bearish/bullish candle appears against position")
momentumLossATR = input.float(0.6, "Momentum Loss Threshold (Body/ATR)", minval=0.3, maxval=1.5, step=0.1, group=grpExit, tooltip="Counter-trend candle body must exceed this to trigger exit")
exitOnStructureFlip = input.bool(true, "Exit on Structure Flip?", group=grpExit, tooltip="Exit when opposite BOS occurs (structure invalidated)")
exitOnConsolidation = input.bool(true, "Exit on Consolidation at Target?", group=grpExit, tooltip="Exit when price consolidates near the target swing level (indicates resistance/support)")
consolidationExitBars = input.int(4, "Consolidation Detection Bars", minval=3, maxval=10, group=grpExit, tooltip="Number of bars to detect consolidation at target")
consolidationExitATR = input.float(1.5, "Consolidation Range (ATR)", minval=0.5, maxval=3.0, step=0.1, group=grpExit, tooltip="Maximum range size for consolidation detection")
exitOnReversalCandle = input.bool(true, "Exit on Reversal Candle?", group=grpExit, tooltip="Exit when hammer (short) or shooting star (long) forms, signaling potential reversal")
reversalWickMultiplier = input.float(2.0, "Reversal Wick Multiplier", minval=1.5, maxval=4.0, step=0.5, group=grpExit, tooltip="Lower wick must be >= this multiple of body for hammer detection")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Styling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpStyle = "ğŸ¨ Styling"
bullColor = input.color(color.rgb(0, 230, 118), "Bullish Color", group=grpStyle)
bearColor = input.color(color.rgb(255, 82, 82), "Bearish Color", group=grpStyle)
neutralColor = input.color(color.gray, "Neutral Color", group=grpStyle)
internalColor = input.color(color.rgb(255, 235, 59), "Internal Structure Color", group=grpStyle)
strongBOSColor = input.color(color.rgb(0, 255, 170), "Strong BOS Color", group=grpStyle)
weakBOSColor = input.color(color.rgb(255, 170, 100), "Weak BOS Color", group=grpStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ AUTO-TIMEFRAME DETECTION â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

currentTFMinutes = timeframe.in_seconds() / 60

var int swingLength = manualSwingLength

if useAutoTF
    if currentTFMinutes <= 1
        swingLength := tf1m
    else if currentTFMinutes <= 5
        swingLength := tf5m
    else if currentTFMinutes <= 15
        swingLength := tf15m
    else if currentTFMinutes <= 30
        swingLength := tf30m
    else if currentTFMinutes <= 60
        swingLength := tf1h
    else if currentTFMinutes <= 240
        swingLength := tf4h
    else if currentTFMinutes <= 1440
        swingLength := tfD
    else
        swingLength := tfW
else
    swingLength := manualSwingLength

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ TYPE DEFINITIONS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type Zone
    box zoneBox
    label zoneLabel
    float top
    float bottom
    int startBar
    bool isSupply
    bool tested
    bool invalidated
    bool hasFVG

type PullbackZone
    box goldenBox
    box deepBox
    line fib0Line
    line fib50Line
    line fib618Line
    line fib786Line
    line fib100Line
    label fib0Label
    label fib50Label
    label fib618Label
    label fib786Label
    label fib100Label
    float fibOrigin       // 0% level (swing low for bull, swing high for bear)
    float fibExtreme      // 100% level (swing high for bull, swing low for bear)
    float fib50Price
    float fib618Price
    float fib786Price
    int direction         // 1 = bullish, -1 = bearish
    int startBar
    bool isActive
    bool enteredZone
    bool confirmationTriggered

// Arrays
var array<line> zigZagLines = array.new<line>()
var array<Zone> activeZones = array.new<Zone>()
var PullbackZone activePullbackZone = na
var array<box> historicalConsolidationBoxes = array.new<box>()

// Arrays for tracking recent swing points (NOT USED IN V6.0 - simple range detection doesn't need swing tracking)
// var array<float> recentSwingHighs = array.new<float>()
// var array<float> recentSwingLows = array.new<float>()
// var array<int> recentSwingHighBars = array.new<int>()
// var array<int> recentSwingLowBars = array.new<int>()
// var int maxSwingsToTrack = 10

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ HELPER FUNCTIONS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bodyClosesAbove(level) =>
    close > level and close[1] <= level

bodyClosesBelow(level) =>
    close < level and close[1] >= level

detectBullishFVG(lookback) =>
    result = false
    for i = 1 to lookback
        if low[i-1] > high[i+1]
            result := true
            break
    result

detectBearishFVG(lookback) =>
    result = false
    for i = 1 to lookback
        if high[i-1] < low[i+1]
            result := true
            break
    result

getLineStyle(styleStr) =>
    switch styleStr
        "Solid" => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted
        => line.style_dashed

// V6.0: Helper functions below not used in simple range detection
// Check if swings in array are clustered in TIME (within maxBarSpread bars of each other)
// isTimesClustered(barArray, maxBarSpread) =>
//     if array.size(barArray) < 2
//         false
//     else
//         oldestBar = array.min(barArray)
//         newestBar = array.max(barArray)
//         barSpan = newestBar - oldestBar
//         barSpan <= maxBarSpread

// Check if there's ATR compression (volatility decreasing)
// isATRCompressed(currentATR, lookback, compressionRatio) =>
//     avgATR = ta.sma(currentATR, lookback)
//     currentATR < (avgATR * compressionRatio)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ PIVOT DETECTION â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Main Swing Structure
swingHigh = ta.pivothigh(high, swingLength, swingLength)
swingLow = ta.pivotlow(low, swingLength, swingLength)

// Internal Structure
internalHigh = ta.pivothigh(high, internalLength, internalLength)
internalLow = ta.pivotlow(low, internalLength, internalLength)

// ATR for displacement grading and zone sizing
atrValue = ta.atr(atrPeriod)

// Track confirmed levels
var float confirmedSwingHigh = na
var float confirmedSwingLow = na
var int confirmedHighBar = na
var int confirmedLowBar = na

var float prevSwingHigh = na
var float prevSwingLow = na
var int prevHighBar = na
var int prevLowBar = na

// V7.0: Track the opposite swing that existed when each swing was confirmed
// This is the correct impulse origin for BOS detection
var float swingLowAtHighConfirm = na   // The swing low when this high was confirmed
var float swingHighAtLowConfirm = na   // The swing high when this low was confirmed
var int swingLowBarAtHighConfirm = na
var int swingHighBarAtLowConfirm = na

// Update swing highs
if not na(swingHigh)
    prevSwingHigh := confirmedSwingHigh
    prevHighBar := confirmedHighBar
    confirmedSwingHigh := swingHigh
    confirmedHighBar := bar_index - swingLength
    // Capture the swing low that exists NOW (origin of the impulse to this high)
    swingLowAtHighConfirm := confirmedSwingLow
    swingLowBarAtHighConfirm := confirmedLowBar

// Update swing lows
if not na(swingLow)
    prevSwingLow := confirmedSwingLow
    prevLowBar := confirmedLowBar
    confirmedSwingLow := swingLow
    confirmedLowBar := bar_index - swingLength
    // Capture the swing high that exists NOW (origin of the impulse to this low)
    swingHighAtLowConfirm := confirmedSwingHigh
    swingHighBarAtLowConfirm := confirmedHighBar

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ MARKET STRUCTURE LOGIC â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Structure State: 1 = bullish, -1 = bearish, 0 = consolidating
var int structureState = 0
var int prevStructureState = 0

// Protected Levels (A4)
var float protectedLow = na
var float protectedHigh = na
var int protectedLowBar = na
var int protectedHighBar = na

// Impulse Range (A5)
var float impulseHigh = na
var float impulseLow = na
var int lastImpulseBar = na

// Consolidation tracking (A1)
var int barsSinceImpulse = 0
var float consolidationRangeHigh = na
var float consolidationRangeLow = na
var int actualConsolidationStart = na  // Track when consolidation actually began
var int barsInTightRange = 0
var bool isConsolidating = false
var bool isRangeTight = false
var box consolidationBox = na

// BOS Strength tracking
var bool lastBOSStrong = false

// V7.2.3: Dynamic Exit Target Tracking
var float highestSwingInRun = na       // Track highest swing high in current bullish run
var float lowestSwingInRun = na        // Track lowest swing low in current bearish run
var float entrySwingTarget = na        // Dynamic exit target (updates as structure progresses)
var int pullbackDirection = 0          // 1 = bullish, -1 = bearish (needed for target updates)

// Entry and Exit signal tracking (declared early for use in target updates)
var bool entryConfirmed = false        // Entry signal triggered
var bool reversalCandleDetected = false // Track if reversal candle has been detected
var float reversalCandleExitLevel = na  // Price level to exit (hammer high for short, shooting star low for long)

// V7.3.0: Momentum Entry Tracking
var bool momentumEntryTaken = false        // Has momentum entry been executed?
var int momentumEntryBar = na              // Bar index of momentum entry
var float momentumEntryPrice = na          // Entry price for momentum entry
var float momentumStopLevel = na           // Stop loss for momentum entry

// V7.3.0: Partial Exit Tracking
var bool t1ExitTriggered = false           // T1 target reached
var bool t2ExitTriggered = false           // T2 target reached
var bool t3ExitTriggered = false           // T3 stopped out
var float t1TargetPrice = na               // T1 price level
var float t2TargetPrice = na               // T2 price level
var float t3TrailStopPrice = na            // Dynamic trail stop
var int remainingPositionPct = 100         // Track position % remaining
var float entryStopDistance = na           // Distance from entry to stop (for R:R calc)

// Target line objects
var line t1TargetLine = na
var line t2TargetLine = na
var line t3TrailLine = na

// Raw BOS detection (before filters)
// Standard: Crossover above/below swing level
rawBullishBOS = not na(confirmedSwingHigh) and bodyClosesAbove(confirmedSwingHigh) and close[1] <= confirmedSwingHigh
rawBearishBOS = not na(confirmedSwingLow) and bodyClosesBelow(confirmedSwingLow) and close[1] >= confirmedSwingLow

// V7.0 FIX: Immediate continuation BOS for strong trending markets
// Problem: In strong trends, by the time a swing is confirmed (swingLength bars later),
// price is already way beyond it, so the crossover condition never triggers.
// Solution: If we're already in bullish/bearish structure AND a new swing high/low just
// got confirmed AND price is already above/below it, that's an immediate continuation BOS.

// New swing high just confirmed AND we're already bullish AND price is above it
trendContinuationBull = not na(swingHigh) and structureState == 1 and close > swingHigh
// New swing low just confirmed AND we're already bearish AND price is below it  
trendContinuationBear = not na(swingLow) and structureState == -1 and close < swingLow

// Combine: Either standard crossover OR immediate trend continuation
rawBullishBOS := rawBullishBOS or trendContinuationBull
rawBearishBOS := rawBearishBOS or trendContinuationBear

// Calculate BOS strength (A6)
bosBodySize = math.abs(close - open)
bosIsStrong = bosBodySize > (atrValue * strongBOSThreshold)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal Structure Filter (A5) - V7.0 REWRITE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SYMMETRIC CONTAINER-BASED TEST: Any break inside [impulseLow, impulseHigh] is internal
// This applies to BOTH bullish and bearish breaks regardless of current structure state
isInsideImpulseRange = false
if useInternalFilter and not na(impulseHigh) and not na(impulseLow)
    // Simple symmetric test: if the breaking price (close) is inside the impulse container,
    // this is an internal break and should NOT flip structure or emit a BOS label
    breakPrice = close
    if breakPrice > impulseLow and breakPrice < impulseHigh
        isInsideImpulseRange := true

// Internal break detection (for labeling)
internalBullBreak = rawBullishBOS and isInsideImpulseRange
internalBearBreak = rawBearishBOS and isInsideImpulseRange

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Protected Level Check (A4) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Structure invalidation via protected levels
protectedLevelBroken = false
if useProtectedLevels
    if structureState == 1 and not na(protectedLow) and close < protectedLow
        protectedLevelBroken := true
    if structureState == -1 and not na(protectedHigh) and close > protectedHigh
        protectedLevelBroken := true

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Final BOS Determination - V7.0 REWRITE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V7.0: BOS valid when:
// - INITIAL STATE (neutral): Any raw BOS establishes direction
// - SAME-BIAS CONTINUATIONS: Always valid if raw break detected (extends impulse)
// - OPPOSITE-BIAS REVERSALS: Protected level break IS the BOS (no swing crossover needed)

// Determine break context
isNeutral = structureState == 0  // Initial/no established structure yet
isBullContinuation = rawBullishBOS and structureState == 1   // Bullish BOS while already bullish
isBearContinuation = rawBearishBOS and structureState == -1  // Bearish BOS while already bearish

// V7.0 FIX: For REVERSALS, breaking the protected level IS the structure flip
// Per SMC: Protected level break = structure invalidation = BOS
// We check for FIRST break of protected level (crossover, not just being above/below)
protectedHighBroken = structureState == -1 and not na(protectedHigh) and close > protectedHigh and close[1] <= protectedHigh
protectedLowBroken = structureState == 1 and not na(protectedLow) and close < protectedLow and close[1] >= protectedLow

// Apply rules:
// - Initial state: Any raw BOS is valid (establishes structure)
// - Continuations: Always valid (extend impulse)
// - Reversals: Protected level break triggers BOS (or rawBOS + protectedBroken for internal breaks that also break protected)
bullishBOS = (isNeutral and rawBullishBOS) or isBullContinuation or protectedHighBroken
bearishBOS = (isNeutral and rawBearishBOS) or isBearContinuation or protectedLowBroken

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Structure State Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Track previous state
prevStructureState := structureState

// Pre-calculate lookback values for protected levels (must be called on every bar for consistency)
lookbackBars = swingLength * protectedLookback
lowestLookback = ta.lowest(low, lookbackBars)
highestLookback = ta.highest(high, lookbackBars)

// Track consolidation state (declared here so it's available in BOS blocks)
var bool wasConsolidating = false
var int consolidationStartBar = na

// Update structure on valid BOS
if bullishBOS
    structureState := 1
    lastBOSStrong := bosIsStrong
    barsSinceImpulse := 0
    wasConsolidating := false
    
    // V7.2.2: Reset target tracking on new bullish structure
    // Start fresh - bearish tracking no longer relevant
    lowestSwingInRun := na
    
    // V7.0 SMC-CORRECT: Protected level = the most recent swing low (HL) at the moment BOS triggers
    // Per ICT/SMC research: "The swing low prior to BOS" is the protected low
    // Using confirmedSwingLow ensures it's the HL that DIRECTLY preceded/enabled this BOS
    // This also ensures protected low TRAILS UP with each continuation BOS
    protectedLow := not na(confirmedSwingLow) ? confirmedSwingLow : lowestLookback
    protectedLowBar := not na(confirmedLowBar) ? confirmedLowBar : bar_index
    
    // Impulse range: origin = protected low, high = highest since that swing
    impulseLow := protectedLow
    
    // Find impulse high: highest since the protected low bar
    barsFromSwing = bar_index - protectedLowBar
    safeBarsFromSwing = math.max(1, math.min(barsFromSwing + 1, bar_index + 1))
    impulseHigh := ta.highest(high, safeBarsFromSwing)
    lastImpulseBar := bar_index
    
    // Mark consolidation as broken (keep historical if enabled)
    if not na(consolidationBox)
        if showHistoricalConsolidation
            // Finalize the box (stop extending, change color)
            box.set_right(consolidationBox, bar_index)
            box.set_bgcolor(consolidationBox, brokenConsolidationColor)
            box.set_border_color(consolidationBox, color.rgb(80, 80, 80))
            
            // Add to historical array
            array.push(historicalConsolidationBoxes, consolidationBox)
            
            // Limit historical boxes
            if array.size(historicalConsolidationBoxes) > maxHistoricalBoxes
                oldBox = array.shift(historicalConsolidationBoxes)
                box.delete(oldBox)
        else
            box.delete(consolidationBox)
        consolidationBox := na

if bearishBOS
    structureState := -1
    lastBOSStrong := bosIsStrong
    barsSinceImpulse := 0
    wasConsolidating := false
    
    // V7.2.2: Reset target tracking on new bearish structure
    // Start fresh - bullish tracking no longer relevant
    highestSwingInRun := na
    
    // V7.0 SMC-CORRECT: Protected level = the most recent swing high (LH) at the moment BOS triggers
    // Per ICT/SMC research: "The swing high prior to BOS" is the protected high
    // Using confirmedSwingHigh ensures it's the LH that DIRECTLY preceded/enabled this BOS
    // This also ensures protected high TRAILS DOWN with each continuation BOS
    protectedHigh := not na(confirmedSwingHigh) ? confirmedSwingHigh : highestLookback
    protectedHighBar := not na(confirmedHighBar) ? confirmedHighBar : bar_index
    
    // Impulse range: origin = protected high, low = lowest since that swing
    impulseHigh := protectedHigh
    
    // Find impulse low: lowest since the protected high bar
    barsFromSwing = bar_index - protectedHighBar
    safeBarsFromSwing = math.max(1, math.min(barsFromSwing + 1, bar_index + 1))
    impulseLow := ta.lowest(low, safeBarsFromSwing)
    lastImpulseBar := bar_index
    
    // Mark consolidation as broken (keep historical if enabled)
    if not na(consolidationBox)
        if showHistoricalConsolidation
            // Finalize the box (stop extending, change color)
            box.set_right(consolidationBox, bar_index)
            box.set_bgcolor(consolidationBox, brokenConsolidationColor)
            box.set_border_color(consolidationBox, color.rgb(80, 80, 80))
            
            // Add to historical array
            array.push(historicalConsolidationBoxes, consolidationBox)
            
            // Limit historical boxes
            if array.size(historicalConsolidationBoxes) > maxHistoricalBoxes
                oldBox = array.shift(historicalConsolidationBoxes)
                box.delete(oldBox)
        else
            box.delete(consolidationBox)
        consolidationBox := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ V7.3.0: Momentum Entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Take immediate entry on strong BOS before waiting for pullback
if enableMomentumEntry and (bullishBOS or bearishBOS)
    // Calculate candle body for displacement check
    candleBody = math.abs(close - open)

    // Check if criteria met for momentum entry
    momentumCriteriaMet = true

    // Filter 1: Strong BOS requirement
    if momentumRequireStrong and not bosIsStrong
        momentumCriteriaMet := false

    // Filter 2: Displacement threshold
    if candleBody < (atrValue * momentumMinDisplacement)
        momentumCriteriaMet := false

    // Execute momentum entry
    if momentumCriteriaMet
        momentumEntryTaken := true
        momentumEntryBar := bar_index
        momentumEntryPrice := close

        // Set stop level based on direction
        if bullishBOS
            momentumStopLevel := protectedLow
            // Initialize target tracking
            if na(highestSwingInRun) or confirmedSwingHigh > highestSwingInRun
                highestSwingInRun := confirmedSwingHigh
            entrySwingTarget := highestSwingInRun
        else
            momentumStopLevel := protectedHigh
            // Initialize target tracking
            if na(lowestSwingInRun) or confirmedSwingLow < lowestSwingInRun
                lowestSwingInRun := confirmedSwingLow
            entrySwingTarget := lowestSwingInRun

        // Reset partial exit tracking for new position
        t1ExitTriggered := false
        t2ExitTriggered := false
        t3ExitTriggered := false
        remainingPositionPct := momentumPositionSize  // Start with momentum size only

        // Draw momentum entry label
        if showMomentumLabels
            labelColor = bullishBOS ? color.rgb(255, 215, 0) : color.rgb(255, 140, 0)  // Gold/Orange
            labelText = "âš¡ ENTRY\n" + str.tostring(momentumPositionSize) + "%"
            labelStyle = bullishBOS ? label.style_label_up : label.style_label_down
            labelY = bullishBOS ? low - atrValue * 0.2 : high + atrValue * 0.2

            label.new(bar_index, labelY, labelText,
                      style=labelStyle,
                      color=labelColor,
                      textcolor=color.white,
                      size=size.small)

// Reset momentum entry on structure flip or max bars
if momentumEntryTaken and not entryConfirmed
    barsElapsed = bar_index - momentumEntryBar

    // Invalidation 1: Structure flip
    structureFlipped = (pullbackDirection == 1 and bearishBOS) or (pullbackDirection == -1 and bullishBOS)

    // Invalidation 2: Max bars without pullback entry
    if structureFlipped or barsElapsed > 15
        momentumEntryTaken := false
        momentumEntryBar := na
        momentumEntryPrice := na
        momentumStopLevel := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Consolidation Detection (A1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Post-BOS Range Logic: True consolidation = range between broken level and next swing
// TEMPORARILY DISABLED - Will revisit consolidation logic later

// CONSOLIDATION DETECTION TEMPORARILY DISABLED
// Will revisit this logic later - for now focusing on core indicator functionality
//
// if useConsolidation
//     // POST-BOS CONSOLIDATION DETECTION  
//     // After BOS: Range = Broken High/Low to Next Swing Low/High
//     // [All consolidation logic commented out]
//

// Increment bars since last BOS (unless currently in BOS)
if not bullishBOS and not bearishBOS
    barsSinceImpulse += 1

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Dynamic Impulse Container Updates - V7.0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// On EVERY bar, extend the impulse container in the direction of the current trend
// This ensures the internal filter always has accurate bounds for break classification
if structureState == 1 and not na(impulseHigh)
    // Bullish: Extend impulse high as price makes new highs
    impulseHigh := math.max(impulseHigh, high)
    // Note: impulseLow (protected low) stays fixed until structure flips

if structureState == -1 and not na(impulseLow)
    // Bearish: Extend impulse low as price makes new lows
    impulseLow := math.min(impulseLow, low)
    // Note: impulseHigh (protected high) stays fixed until structure flips

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Protected Level Trailing - V7.0 SMC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Per SMC: Protected levels should TRAIL with structure-confirming swings
// When a new swing confirms existing structure, update the protected level
// This ensures reversal detection uses the correct, current level

// Bullish structure: Trail protected low UP when new Higher Low is confirmed
if structureState == 1 and not na(swingLow)
    // New swing low detected - check if it's a Higher Low (confirms bullish structure)
    if swingLow > protectedLow
        protectedLow := swingLow
        protectedLowBar := bar_index - swingLength
        impulseLow := swingLow  // Also update impulse origin

// Bearish structure: Trail protected high DOWN when new Lower High is confirmed
if structureState == -1 and not na(swingHigh)
    // New swing high detected - check if it's a Lower High (confirms bearish structure)
    if swingHigh < protectedHigh
        protectedHigh := swingHigh
        protectedHighBar := bar_index - swingLength
        impulseHigh := swingHigh  // Also update impulse origin

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Dynamic Exit Target Updates - V7.2.3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Update exit target dynamically as new swing highs/lows are confirmed
// This ensures target tracks the highest swing in current structure (progressive targeting)
// V7.3: Only update target BEFORE entry is confirmed - locks target at entry time

// Bullish structure: Update target when new swing high confirmed (only before entry)
if structureState == 1 and pullbackDirection == 1 and not na(swingHigh) and not entryConfirmed
    // New swing high just confirmed - check if it's higher than current target
    if swingHigh > highestSwingInRun or na(highestSwingInRun)
        highestSwingInRun := swingHigh
        entrySwingTarget := highestSwingInRun

// Bearish structure: Update target when new swing low confirmed (only before entry)
if structureState == -1 and pullbackDirection == -1 and not na(swingLow) and not entryConfirmed
    // New swing low just confirmed - check if it's lower than current target
    if swingLow < lowestSwingInRun or na(lowestSwingInRun)
        lowestSwingInRun := swingLow
        entrySwingTarget := lowestSwingInRun

// Liquidity Sweep detection
bullSweep = showLiqSweeps and not na(confirmedSwingHigh) and high > confirmedSwingHigh and close <= confirmedSwingHigh
bearSweep = showLiqSweeps and not na(confirmedSwingLow) and low < confirmedSwingLow and close >= confirmedSwingLow

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ VISUALIZATION â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Protected Level Lines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var line protectedLowLine = na
var line protectedHighLine = na
var label protectedLowLabel = na
var label protectedHighLabel = na

if showProtectedLines and useProtectedLevels
    lineStyle = getLineStyle(protectedLineStyle)
    
    // Update/create protected low line (bullish structure)
    if structureState == 1 and not na(protectedLow)
        // Use a reasonable start bar - either the protectedLowBar or a recent lookback if too old
        lineStartBar = not na(protectedLowBar) ? math.max(protectedLowBar, bar_index - 200) : bar_index - 50
        
        if na(protectedLowLine)
            protectedLowLine := line.new(lineStartBar, protectedLow, bar_index + 5, protectedLow,
                                         color=bullColor, width=2, style=lineStyle)
            protectedLowLabel := label.new(bar_index + 5, protectedLow, "Protected Low",
                                           style=label.style_label_left,
                                           color=color.new(bullColor, 80),
                                           textcolor=bullColor,
                                           size=size.tiny)
        else
            line.set_x1(protectedLowLine, lineStartBar)
            line.set_x2(protectedLowLine, bar_index + 5)
            line.set_y1(protectedLowLine, protectedLow)
            line.set_y2(protectedLowLine, protectedLow)
            label.set_x(protectedLowLabel, bar_index + 5)
            label.set_y(protectedLowLabel, protectedLow)
    else
        if not na(protectedLowLine)
            line.delete(protectedLowLine)
            label.delete(protectedLowLabel)
            protectedLowLine := na
            protectedLowLabel := na
    
    // Update/create protected high line (bearish structure)
    if structureState == -1 and not na(protectedHigh)
        // Use a reasonable start bar - either the protectedHighBar or a recent lookback if too old
        lineStartBarHigh = not na(protectedHighBar) ? math.max(protectedHighBar, bar_index - 200) : bar_index - 50
        
        if na(protectedHighLine)
            protectedHighLine := line.new(lineStartBarHigh, protectedHigh, bar_index + 5, protectedHigh,
                                          color=bearColor, width=2, style=lineStyle)
            protectedHighLabel := label.new(bar_index + 5, protectedHigh, "Protected High",
                                            style=label.style_label_left,
                                            color=color.new(bearColor, 80),
                                            textcolor=bearColor,
                                            size=size.tiny)
        else
            line.set_x1(protectedHighLine, lineStartBarHigh)
            line.set_x2(protectedHighLine, bar_index + 5)
            line.set_y1(protectedHighLine, protectedHigh)
            line.set_y2(protectedHighLine, protectedHigh)
            label.set_x(protectedHighLabel, bar_index + 5)
            label.set_y(protectedHighLabel, protectedHigh)
    else
        if not na(protectedHighLine)
            line.delete(protectedHighLine)
            label.delete(protectedHighLabel)
            protectedHighLine := na
            protectedHighLabel := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Swing High/Low Labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if showLabels and not na(swingHigh)
    isHigherHigh = not na(prevSwingHigh) and swingHigh > prevSwingHigh
    isLowerHigh = not na(prevSwingHigh) and swingHigh < prevSwingHigh
    labelColor = isHigherHigh ? bullColor : (isLowerHigh ? bearColor : neutralColor)
    
    if isHigherHigh
        labelText = "HH\n" + str.tostring(swingHigh, format.mintick)
        label.new(bar_index - swingLength, swingHigh, labelText, 
                  style=label.style_label_down, 
                  color=color.new(labelColor, 80), 
                  textcolor=color.white, 
                  size=size.small)
    else
        labelText = isLowerHigh ? "LH" : "H"
        label.new(bar_index - swingLength, swingHigh, labelText, 
                  style=label.style_label_down, 
                  color=color.new(labelColor, 80), 
                  textcolor=labelColor, 
                  size=size.small)

if showLabels and not na(swingLow)
    isHigherLow = not na(prevSwingLow) and swingLow > prevSwingLow
    isLowerLow = not na(prevSwingLow) and swingLow < prevSwingLow
    labelColor = isHigherLow ? bullColor : (isLowerLow ? bearColor : neutralColor)
    
    if isLowerLow
        labelText = "LL\n" + str.tostring(swingLow, format.mintick)
        label.new(bar_index - swingLength, swingLow, labelText, 
                  style=label.style_label_up, 
                  color=color.new(labelColor, 80), 
                  textcolor=color.white, 
                  size=size.small)
    else
        labelText = isHigherLow ? "HL" : "L"
        label.new(bar_index - swingLength, swingLow, labelText, 
                  style=label.style_label_up, 
                  color=color.new(labelColor, 80), 
                  textcolor=labelColor, 
                  size=size.small)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal Structure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if showInternalStructure and not na(internalHigh)
    label.new(bar_index - internalLength, internalHigh, "iH", 
              style=label.style_label_down, 
              color=color.new(internalColor, 70), 
              textcolor=internalColor, 
              size=size.tiny)
    line.new(bar_index - internalLength, internalHigh, bar_index + 5, internalHigh, 
             color=color.new(internalColor, 50), 
             width=1, 
             style=line.style_dotted)

if showInternalStructure and not na(internalLow)
    label.new(bar_index - internalLength, internalLow, "iL", 
              style=label.style_label_up, 
              color=color.new(internalColor, 70), 
              textcolor=internalColor, 
              size=size.tiny)
    line.new(bar_index - internalLength, internalLow, bar_index + 5, internalLow, 
             color=color.new(internalColor, 50), 
             width=1, 
             style=line.style_dotted)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal Break Labels (A5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if showInternalBreaks and internalBullBreak
    // Draw dotted line at the internal break level
    if not na(confirmedHighBar)
        line.new(confirmedHighBar, confirmedSwingHigh, bar_index + 10, confirmedSwingHigh, 
                 color=color.new(bullColor, 50), 
                 width=1, 
                 style=line.style_dotted)
    
    label.new(bar_index, high, "iBOSâ†‘", 
              style=label.style_label_down, 
              color=color.new(bullColor, 70), 
              textcolor=bullColor, 
              size=size.tiny)

if showInternalBreaks and internalBearBreak
    // Draw dotted line at the internal break level
    if not na(confirmedLowBar)
        line.new(confirmedLowBar, confirmedSwingLow, bar_index + 10, confirmedSwingLow, 
                 color=color.new(bearColor, 50), 
                 width=1, 
                 style=line.style_dotted)
    
    label.new(bar_index, low, "iBOSâ†“", 
              style=label.style_label_up, 
              color=color.new(bearColor, 70), 
              textcolor=bearColor, 
              size=size.tiny)

// Trap warnings
if showTrapWarnings and internalBullBreak
    label.new(bar_index, high + atrValue * 0.2, "âš ï¸ TRAP?", 
              style=label.style_label_down, 
              color=color.new(color.orange, 50), 
              textcolor=color.orange, 
              size=size.tiny)

if showTrapWarnings and internalBearBreak
    label.new(bar_index, low - atrValue * 0.2, "âš ï¸ TRAP?", 
              style=label.style_label_up, 
              color=color.new(color.orange, 50), 
              textcolor=color.orange, 
              size=size.tiny)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Zig-Zag Path (Array-Based) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var array<float> zzPrices = array.new<float>()
var array<int> zzBars = array.new<int>()
var array<bool> zzIsHigh = array.new<bool>()

if showZigZag
    // Process swing HIGH
    if not na(swingHigh)
        currentHighBar = bar_index - swingLength
        currentHighPrice = swingHigh
        
        if array.size(zzIsHigh) > 0 and array.get(zzIsHigh, array.size(zzIsHigh) - 1) == true
            lastPrice = array.get(zzPrices, array.size(zzPrices) - 1)
            if currentHighPrice > lastPrice
                array.set(zzPrices, array.size(zzPrices) - 1, currentHighPrice)
                array.set(zzBars, array.size(zzBars) - 1, currentHighBar)
                
                if array.size(zigZagLines) > 0
                    lastLine = array.pop(zigZagLines)
                    line.delete(lastLine)
                    
                    if array.size(zzPrices) >= 2
                        prevPrice = array.get(zzPrices, array.size(zzPrices) - 2)
                        prevBar = array.get(zzBars, array.size(zzBars) - 2)
                        zigColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
                        newLine = line.new(prevBar, prevPrice, currentHighBar, currentHighPrice, 
                                 color=zigColor, width=2, style=line.style_solid)
                        array.push(zigZagLines, newLine)
        else
            array.push(zzPrices, currentHighPrice)
            array.push(zzBars, currentHighBar)
            array.push(zzIsHigh, true)
            
            if array.size(zzPrices) >= 2
                prevPrice = array.get(zzPrices, array.size(zzPrices) - 2)
                prevBar = array.get(zzBars, array.size(zzBars) - 2)
                zigColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
                newLine = line.new(prevBar, prevPrice, currentHighBar, currentHighPrice, 
                         color=zigColor, width=2, style=line.style_solid)
                array.push(zigZagLines, newLine)
                
                if array.size(zigZagLines) > maxZigZagLines
                    oldLine = array.shift(zigZagLines)
                    line.delete(oldLine)
            
            if array.size(zzPrices) > maxZigZagLines + 1
                array.shift(zzPrices)
                array.shift(zzBars)
                array.shift(zzIsHigh)
    
    // Process swing LOW
    if not na(swingLow)
        currentLowBar = bar_index - swingLength
        currentLowPrice = swingLow
        
        if array.size(zzIsHigh) > 0 and array.get(zzIsHigh, array.size(zzIsHigh) - 1) == false
            lastPrice = array.get(zzPrices, array.size(zzPrices) - 1)
            if currentLowPrice < lastPrice
                array.set(zzPrices, array.size(zzPrices) - 1, currentLowPrice)
                array.set(zzBars, array.size(zzBars) - 1, currentLowBar)
                
                if array.size(zigZagLines) > 0
                    lastLine = array.pop(zigZagLines)
                    line.delete(lastLine)
                    
                    if array.size(zzPrices) >= 2
                        prevPrice = array.get(zzPrices, array.size(zzPrices) - 2)
                        prevBar = array.get(zzBars, array.size(zzBars) - 2)
                        zigColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
                        newLine = line.new(prevBar, prevPrice, currentLowBar, currentLowPrice, 
                                 color=zigColor, width=2, style=line.style_solid)
                        array.push(zigZagLines, newLine)
        else
            array.push(zzPrices, currentLowPrice)
            array.push(zzBars, currentLowBar)
            array.push(zzIsHigh, false)
            
            if array.size(zzPrices) >= 2
                prevPrice = array.get(zzPrices, array.size(zzPrices) - 2)
                prevBar = array.get(zzBars, array.size(zzBars) - 2)
                zigColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
                newLine = line.new(prevBar, prevPrice, currentLowBar, currentLowPrice, 
                         color=zigColor, width=2, style=line.style_solid)
                array.push(zigZagLines, newLine)
                
                if array.size(zigZagLines) > maxZigZagLines
                    oldLine = array.shift(zigZagLines)
                    line.delete(oldLine)
            
            if array.size(zzPrices) > maxZigZagLines + 1
                array.shift(zzPrices)
                array.shift(zzBars)
                array.shift(zzIsHigh)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Developing Swing Level Lines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These show the active levels that need to break for BOS - visible BEFORE confirmation
var line developingHighLine = na
var line developingLowLine = na
var label developingHighLabel = na
var label developingLowLabel = na

if showDevelopingLevels
    // Update developing high line (level to break for bullish BOS)
    if not na(confirmedSwingHigh) and not na(confirmedHighBar)
        // Delete old line and recreate (to extend it)
        if not na(developingHighLine)
            line.delete(developingHighLine)
        if not na(developingHighLabel)
            label.delete(developingHighLabel)
        
        // Only show if not already broken
        if close <= confirmedSwingHigh
            developingHighLine := line.new(confirmedHighBar, confirmedSwingHigh, bar_index + 10, confirmedSwingHigh,
                                           color=color.new(bearColor, 50), width=1, style=line.style_dashed)
            developingHighLabel := label.new(bar_index + 10, confirmedSwingHigh, "SH", 
                                             style=label.style_label_left,
                                             color=color.new(bearColor, 85),
                                             textcolor=bearColor,
                                             size=size.tiny)
    
    // Update developing low line (level to break for bearish BOS)
    if not na(confirmedSwingLow) and not na(confirmedLowBar)
        // Delete old line and recreate (to extend it)
        if not na(developingLowLine)
            line.delete(developingLowLine)
        if not na(developingLowLabel)
            label.delete(developingLowLabel)
        
        // Only show if not already broken
        if close >= confirmedSwingLow
            developingLowLine := line.new(confirmedLowBar, confirmedSwingLow, bar_index + 10, confirmedSwingLow,
                                          color=color.new(bullColor, 50), width=1, style=line.style_dashed)
            developingLowLabel := label.new(bar_index + 10, confirmedSwingLow, "SL",
                                            style=label.style_label_left,
                                            color=color.new(bullColor, 85),
                                            textcolor=bullColor,
                                            size=size.tiny)
else
    // Clean up lines when setting is disabled
    if not na(developingHighLine)
        line.delete(developingHighLine)
        developingHighLine := na
    if not na(developingHighLabel)
        label.delete(developingHighLabel)
        developingHighLabel := na
    if not na(developingLowLine)
        line.delete(developingLowLine)
        developingLowLine := na
    if not na(developingLowLabel)
        label.delete(developingLowLabel)
        developingLowLabel := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BOS Lines with Strength Grading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// When BOS confirms, draw the solid confirmation line and label
if bullishBOS and not na(confirmedHighBar)
    // Remove the developing line since it's now confirmed
    if not na(developingHighLine)
        line.delete(developingHighLine)
        developingHighLine := na
    if not na(developingHighLabel)
        label.delete(developingHighLabel)
        developingHighLabel := na
    
    // Determine color based on strength - bullish uses green tones
    bosColor = bullColor
    if useDisplacementGrading
        bosColor := bosIsStrong ? color.rgb(0, 255, 100) : color.rgb(0, 180, 80)  // Bright green / dimmer green
    else
        bosColor := bullColor
    
    strengthSuffix = ""
    if useDisplacementGrading and showStrengthLabels
        strengthSuffix := bosIsStrong ? " (S)" : " (W)"
    
    line.new(confirmedHighBar, confirmedSwingHigh, bar_index, confirmedSwingHigh, 
             color=bosColor, width=2, style=line.style_solid)
    label.new(bar_index, confirmedSwingHigh, "BOS â†‘" + strengthSuffix, 
              style=label.style_label_down, 
              color=color.new(bosColor, 80), 
              textcolor=bosColor, 
              size=size.small)

if bearishBOS and not na(confirmedLowBar)
    // Remove the developing line since it's now confirmed
    if not na(developingLowLine)
        line.delete(developingLowLine)
        developingLowLine := na
    if not na(developingLowLabel)
        label.delete(developingLowLabel)
        developingLowLabel := na
    
    // Determine color based on strength - bearish uses red tones
    bosColor = bearColor
    if useDisplacementGrading
        bosColor := bosIsStrong ? color.rgb(255, 50, 50) : color.rgb(200, 80, 80)  // Bright red / dimmer red
    else
        bosColor := bearColor
    
    strengthSuffix = ""
    if useDisplacementGrading and showStrengthLabels
        strengthSuffix := bosIsStrong ? " (S)" : " (W)"
    
    line.new(confirmedLowBar, confirmedSwingLow, bar_index, confirmedSwingLow, 
             color=bosColor, width=2, style=line.style_solid)
    label.new(bar_index, confirmedSwingLow, "BOS â†“" + strengthSuffix, 
              style=label.style_label_up, 
              color=color.new(bosColor, 80), 
              textcolor=bosColor, 
              size=size.small)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Liquidity Sweeps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if bullSweep and not na(confirmedHighBar)
    line.new(confirmedHighBar, confirmedSwingHigh, bar_index, confirmedSwingHigh, 
             color=bearColor, width=1, style=line.style_dotted)
    label.new(bar_index, high, "Sweep", 
              style=label.style_xcross, 
              color=color.new(bearColor, 80), 
              textcolor=bearColor, 
              size=size.tiny)

if bearSweep and not na(confirmedLowBar)
    line.new(confirmedLowBar, confirmedSwingLow, bar_index, confirmedSwingLow, 
             color=bullColor, width=1, style=line.style_dotted)
    label.new(bar_index, low, "Sweep", 
              style=label.style_xcross, 
              color=color.new(bullColor, 80), 
              textcolor=bullColor, 
              size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ SUPPLY/DEMAND ZONES (A7) â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Zone colors
demandZoneColor = color.new(bullColor, 85)
supplyZoneColor = color.new(bearColor, 85)

// Create Demand Zone on Bullish BOS at the SWING LOW that preceded the move
// PHASE 1 FILTER: Require Strong BOS
createDemandZone = showZones and bullishBOS and not na(confirmedSwingLow) and not na(confirmedLowBar)
if requireStrongBOS
    createDemandZone := createDemandZone and bosIsStrong
if zoneDirectionFilter
    createDemandZone := createDemandZone and structureState == 1

if createDemandZone
    hasFVG = detectBullishFVG(5)
    
    if hasFVG or not requireFVG
        // Use confirmed swing low as the zone level (the actual pivot)
        zoneTop = confirmedSwingLow + atrValue * 0.1
        zoneBottom = confirmedSwingLow - atrValue * 0.4
        
        // Check if a demand zone already exists at this level (within 0.5 ATR)
        zoneExists = false
        if array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                existingZone = array.get(activeZones, i)
                if not existingZone.isSupply
                    // Check if zones overlap
                    if math.abs(existingZone.top - zoneTop) < atrValue * 0.5
                        zoneExists := true
                        break
        
        if not zoneExists
            zoneBox = box.new(confirmedLowBar, zoneTop, bar_index + zoneExtendBars, zoneBottom,
                              bgcolor=demandZoneColor, 
                              border_color=bullColor,
                              border_width=1)
            
            zoneLbl = label.new(confirmedLowBar, zoneBottom, "DEMAND", 
                               style=label.style_label_up,
                               color=color.new(bullColor, 90),
                               textcolor=bullColor,
                               size=size.tiny)
            
            newZone = Zone.new(zoneBox, zoneLbl, zoneTop, zoneBottom, confirmedLowBar, false, false, false, hasFVG)
            array.push(activeZones, newZone)
            
            if array.size(activeZones) > maxZones
                oldZone = array.shift(activeZones)
                box.delete(oldZone.zoneBox)
                label.delete(oldZone.zoneLabel)

// V7.0: Optional Internal Demand Zone (at internal bullish breaks)
// Internal zones IGNORE direction filter - they're reference zones, so show in both BULL and BEAR
createInternalDemandZone = showZones and showInternalZones and internalBullBreak and not na(confirmedSwingLow) and not na(confirmedLowBar)

if createInternalDemandZone
    hasFVG = detectBullishFVG(5)
    
    if hasFVG or not requireFVG
        zoneTop = confirmedSwingLow + atrValue * 0.1
        zoneBottom = confirmedSwingLow - atrValue * 0.4
        
        zoneExists = false
        if array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                existingZone = array.get(activeZones, i)
                if not existingZone.isSupply
                    if math.abs(existingZone.top - zoneTop) < atrValue * 0.5
                        zoneExists := true
                        break
        
        if not zoneExists
            // Internal zones are DIMMER (95 transparency vs 85)
            internalDemandColor = color.new(bullColor, 95)
            zoneBox = box.new(confirmedLowBar, zoneTop, bar_index + zoneExtendBars, zoneBottom,
                              bgcolor=internalDemandColor, 
                              border_color=color.new(bullColor, 70),
                              border_width=1,
                              border_style=line.style_dotted)  // Dotted border
            
            zoneLbl = label.new(confirmedLowBar, zoneBottom, "iDEMAND",  // Different label
                               style=label.style_label_up,
                               color=color.new(bullColor, 95),
                               textcolor=color.new(bullColor, 30),
                               size=size.tiny)
            
            newZone = Zone.new(zoneBox, zoneLbl, zoneTop, zoneBottom, confirmedLowBar, false, false, false, hasFVG)
            array.push(activeZones, newZone)
            
            if array.size(activeZones) > maxZones
                oldZone = array.shift(activeZones)
                box.delete(oldZone.zoneBox)
                label.delete(oldZone.zoneLabel)

// Create Supply Zone on Bearish BOS at the SWING HIGH that preceded the move
// PHASE 1 FILTER: Require Strong BOS
createSupplyZone = showZones and bearishBOS and not na(confirmedSwingHigh) and not na(confirmedHighBar)
if requireStrongBOS
    createSupplyZone := createSupplyZone and bosIsStrong
if zoneDirectionFilter
    createSupplyZone := createSupplyZone and structureState == -1

if createSupplyZone
    hasFVG = detectBearishFVG(5)
    
    if hasFVG or not requireFVG
        // Use confirmed swing high as the zone level (the actual pivot)
        zoneBottom = confirmedSwingHigh - atrValue * 0.1
        zoneTop = confirmedSwingHigh + atrValue * 0.4
        
        // Check if a supply zone already exists at this level (within 0.5 ATR)
        zoneExists = false
        if array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                existingZone = array.get(activeZones, i)
                if existingZone.isSupply
                    // Check if zones overlap
                    if math.abs(existingZone.bottom - zoneBottom) < atrValue * 0.5
                        zoneExists := true
                        break
        
        if not zoneExists
            zoneBox = box.new(confirmedHighBar, zoneTop, bar_index + zoneExtendBars, zoneBottom,
                              bgcolor=supplyZoneColor, 
                              border_color=bearColor,
                              border_width=1)
            
            zoneLbl = label.new(confirmedHighBar, zoneTop, "SUPPLY", 
                               style=label.style_label_down,
                               color=color.new(bearColor, 90),
                               textcolor=bearColor,
                               size=size.tiny)
            
            newZone = Zone.new(zoneBox, zoneLbl, zoneTop, zoneBottom, confirmedHighBar, true, false, false, hasFVG)
            array.push(activeZones, newZone)
            
            if array.size(activeZones) > maxZones
                oldZone = array.shift(activeZones)
                box.delete(oldZone.zoneBox)
                label.delete(oldZone.zoneLabel)

// V7.0: Optional Internal Supply Zone (at internal bearish breaks)
// Internal zones IGNORE direction filter - they're reference zones, so show in both BULL and BEAR
createInternalSupplyZone = showZones and showInternalZones and internalBearBreak and not na(confirmedSwingHigh) and not na(confirmedHighBar)

if createInternalSupplyZone
    hasFVG = detectBearishFVG(5)
    
    if hasFVG or not requireFVG
        zoneBottom = confirmedSwingHigh - atrValue * 0.1
        zoneTop = confirmedSwingHigh + atrValue * 0.4
        
        zoneExists = false
        if array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                existingZone = array.get(activeZones, i)
                if existingZone.isSupply
                    if math.abs(existingZone.bottom - zoneBottom) < atrValue * 0.5
                        zoneExists := true
                        break
        
        if not zoneExists
            // Internal zones are DIMMER (95 transparency vs 85)
            internalSupplyColor = color.new(bearColor, 95)
            zoneBox = box.new(confirmedHighBar, zoneTop, bar_index + zoneExtendBars, zoneBottom,
                              bgcolor=internalSupplyColor, 
                              border_color=color.new(bearColor, 70),
                              border_width=1,
                              border_style=line.style_dotted)  // Dotted border
            
            zoneLbl = label.new(confirmedHighBar, zoneTop, "iSUPPLY",  // Different label
                               style=label.style_label_down,
                               color=color.new(bearColor, 95),
                               textcolor=color.new(bearColor, 30),
                               size=size.tiny)
            
            newZone = Zone.new(zoneBox, zoneLbl, zoneTop, zoneBottom, confirmedHighBar, true, false, false, hasFVG)
            array.push(activeZones, newZone)
            
            if array.size(activeZones) > maxZones
                oldZone = array.shift(activeZones)
                box.delete(oldZone.zoneBox)
                label.delete(oldZone.zoneLabel)

// Update zone status
if array.size(activeZones) > 0
    for i = array.size(activeZones) - 1 to 0
        zone = array.get(activeZones, i)
        
        // Check if zone is touched
        if not zone.tested
            if (zone.isSupply and high >= zone.bottom) or (not zone.isSupply and low <= zone.top)
                zone.tested := true
                box.set_bgcolor(zone.zoneBox, color.new(color.yellow, 85))
        
        // Check if zone is invalidated
        if not zone.invalidated
            if (zone.isSupply and close > zone.top) or (not zone.isSupply and close < zone.bottom)
                zone.invalidated := true
                if removeMitigated
                    box.delete(zone.zoneBox)
                    label.delete(zone.zoneLabel)
                    array.remove(activeZones, i)
                else
                    box.set_bgcolor(zone.zoneBox, color.new(color.gray, 90))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ PULLBACK ENTRY (FIB GOLDEN ZONE) â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track swing points for fib calculation
var float bosSwingLow = na      // Origin for bullish fib (0%)
var float bosSwingHigh = na     // Extreme for bullish fib (100%)
var int bosSwingLowBar = na
var int bosSwingHighBar = na

// Pullback zone visualization objects
var box goldenZoneBox = na
var box deepZoneBox = na
var line fib0Line = na
var line fib50Line = na
var line fib618Line = na
var line fib786Line = na
var line fib100Line = na
var label fib0Label = na
var label fib50Label = na
var label fib618Label = na
var label fib786Label = na
var label fib100Label = na

// Pullback zone state
var float currentFibOrigin = na
var float currentFibExtreme = na
var float currentFib50 = na
var float currentFib618 = na
var float currentFib786 = na
// Note: pullbackDirection moved to structure section (line 346) to allow early access
var bool inGoldenZone = false
var bool inDeepZone = false
var bool pullbackConfirmed = false
var int pullbackStartBar = na
var int barsInGoldenZone = 0      // Track how long price stays in zone
var bool hasEnteredDeep = false    // Track if price reached 0.618 or deeper
var float deepestPullbackLevel = na // Track deepest retracement level

// Internal structure tracking for confirmation
var float internalSwingHigh = na
var float internalSwingLow = na

// Entry and Exit signal tracking
// Note: entryConfirmed, reversalCandleDetected, reversalCandleExitLevel moved to structure section (lines 349-351)
var int entryBar = na                  // Bar when entry occurred
var float entryPrice = na              // Price at entry
// Note: entrySwingTarget, highestSwingInRun, lowestSwingInRun moved to structure section (lines 344-346)
var bool exitSignalShown = false       // Exit signal already shown
var bool protectedLevelTested = false  // Track if protected level was touched during pullback
var int barsForGoStatus = 0            // Track bars since entry for GO status (show for 3 bars)
var int barsNearTarget = 0             // Track how long price stays near target

// Detect internal structure for confirmation
miniSwingHigh = ta.pivothigh(high, internalLength, internalLength)
miniSwingLow = ta.pivotlow(low, internalLength, internalLength)

if not na(miniSwingHigh)
    internalSwingHigh := miniSwingHigh
if not na(miniSwingLow)
    internalSwingLow := miniSwingLow

// Function to clean up pullback zone visuals
cleanupPullbackZone() =>
    if not na(goldenZoneBox)
        box.delete(goldenZoneBox)
    if not na(deepZoneBox)
        box.delete(deepZoneBox)
    if not na(fib0Line)
        line.delete(fib0Line)
    if not na(fib50Line)
        line.delete(fib50Line)
    if not na(fib618Line)
        line.delete(fib618Line)
    if not na(fib786Line)
        line.delete(fib786Line)
    if not na(fib100Line)
        line.delete(fib100Line)
    if not na(fib0Label)
        label.delete(fib0Label)
    if not na(fib50Label)
        label.delete(fib50Label)
    if not na(fib618Label)
        label.delete(fib618Label)
    if not na(fib786Label)
        label.delete(fib786Label)
    if not na(fib100Label)
        label.delete(fib100Label)
    true

// Create new pullback zone on BOS
if showPullbackZone
    // Bullish BOS - set up for bullish pullback entry
    if bullishBOS and not na(impulseLow) and not na(impulseHigh)
        // Clean up old zone
        cleanupPullbackZone()

        // V7.0: Fib anchors use ACTIVE IMPULSE RANGE (not old swing points)
        // This ensures fibs draw from the current leg, preventing old-structure anchoring
        // Spec: Fib Low (0%) = impulse origin, Fib High (100%) = impulse extreme
        currentFibOrigin := impulseLow       // Origin of the bullish impulse
        currentFibExtreme := impulseHigh     // Current impulse extreme (updates dynamically)

        pullbackDirection := 1
        pullbackStartBar := bar_index
        pullbackConfirmed := false
        inGoldenZone := false
        inDeepZone := false
        barsInGoldenZone := 0
        hasEnteredDeep := false
        deepestPullbackLevel := na
        
        // V7.2.2: Dynamic progressive target system
        // Target = highest confirmed swing high in the current bullish structure
        // This ensures target progresses as new highs are made
        if na(highestSwingInRun) or confirmedSwingHigh > highestSwingInRun
            highestSwingInRun := confirmedSwingHigh
        entrySwingTarget := highestSwingInRun
        
        exitSignalShown := false
        entryConfirmed := false
        barsNearTarget := 0
        reversalCandleDetected := false
        reversalCandleExitLevel := na
        protectedLevelTested := false  // V7.2: Reset on new BOS

        // Calculate fib levels (for bullish: retracement goes DOWN from impulse high to impulse low)
        fibRange = currentFibExtreme - currentFibOrigin
        currentFib50 := currentFibExtreme - (fibRange * fibUpperLevel)
        currentFib618 := currentFibExtreme - (fibRange * fibLowerLevel)
        currentFib786 := currentFibExtreme - (fibRange * fibDeepLevel)

        // Reset internal swing for confirmation tracking
        internalSwingHigh := na

    // Bearish BOS - set up for bearish pullback entry
    if bearishBOS and not na(impulseHigh) and not na(impulseLow)
        // Clean up old zone
        cleanupPullbackZone()

        // V7.0: Fib anchors use ACTIVE IMPULSE RANGE (not old swing points)
        // Spec: Fib High (0%) = impulse origin, Fib Low (100%) = impulse extreme
        currentFibOrigin := impulseHigh      // Origin of the bearish impulse
        currentFibExtreme := impulseLow      // Current impulse extreme (updates dynamically)

        pullbackDirection := -1
        pullbackStartBar := bar_index
        pullbackConfirmed := false
        inGoldenZone := false
        inDeepZone := false
        barsInGoldenZone := 0
        hasEnteredDeep := false
        deepestPullbackLevel := na
        
        // V7.2.2: Dynamic progressive target system
        // Target = lowest confirmed swing low in the current bearish structure
        // This ensures target progresses as new lows are made
        if na(lowestSwingInRun) or confirmedSwingLow < lowestSwingInRun
            lowestSwingInRun := confirmedSwingLow
        entrySwingTarget := lowestSwingInRun

        exitSignalShown := false
        entryConfirmed := false
        barsNearTarget := 0
        reversalCandleDetected := false
        reversalCandleExitLevel := na
        protectedLevelTested := false  // V7.2: Reset on new BOS

        // Calculate fib levels (for bearish: retracement goes UP from impulse low to impulse high)
        fibRange = currentFibOrigin - currentFibExtreme
        currentFib50 := currentFibExtreme + (fibRange * fibUpperLevel)
        currentFib618 := currentFibExtreme + (fibRange * fibLowerLevel)
        currentFib786 := currentFibExtreme + (fibRange * fibDeepLevel)

        // Reset internal swing for confirmation tracking
        internalSwingLow := na

// Update and draw pullback zone
if showPullbackZone and pullbackDirection != 0 and not na(currentFibOrigin)
    // Check if structure invalidated (protected level broken)
    zoneInvalidated = false
    if pullbackDirection == 1 and structureState != 1
        zoneInvalidated := true
    if pullbackDirection == -1 and structureState != -1
        zoneInvalidated := true

    // V7.2: Max Bars filter - expire zone if too many bars since BOS
    barsSinceBOS = bar_index - pullbackStartBar
    zoneExpired = not na(pullbackStartBar) and barsSinceBOS > maxBarsForEntry

    // Note: Removed overly strict origin check - valid pullbacks can go to 0.786 or 1.0 fib
    // Zone persists as historical reference until replaced by new zone

    if zoneInvalidated or zoneExpired
        // Don't cleanup - keep zone visible as historical reference
        // It will be replaced when next BOS creates a new zone
        pullbackDirection := 0
        currentFibOrigin := na
    else
        // V7.0: Dynamically sync fib extreme with impulse values
        // impulseHigh/Low update every bar as the impulse extends (per spec H1/H2)
        // The fib must track these updates to capture new extremes like the 80,600 low
        if pullbackDirection == 1
            currentFibExtreme := impulseHigh  // Sync with dynamic impulse high
            // Recalc fib levels
            fibRange = currentFibExtreme - currentFibOrigin
            if fibRange > 0
                currentFib50 := currentFibExtreme - (fibRange * fibUpperLevel)
                currentFib618 := currentFibExtreme - (fibRange * fibLowerLevel)
                currentFib786 := currentFibExtreme - (fibRange * fibDeepLevel)
        
        if pullbackDirection == -1
            currentFibExtreme := impulseLow  // Sync with dynamic impulse low
            // Recalc fib levels
            fibRange = currentFibOrigin - currentFibExtreme
            if fibRange > 0
                currentFib50 := currentFibExtreme + (fibRange * fibUpperLevel)
                currentFib618 := currentFibExtreme + (fibRange * fibLowerLevel)
                currentFib786 := currentFibExtreme + (fibRange * fibDeepLevel)

        // Check if price is in golden zone
        wasInZone = inGoldenZone
        if pullbackDirection == 1
            inGoldenZone := low <= currentFib50 and close >= currentFib618
            inDeepZone := low <= currentFib618 and close >= currentFib786
            // Track deepest level reached
            if low <= currentFib618
                hasEnteredDeep := true
                deepestPullbackLevel := math.min(na(deepestPullbackLevel) ? low : deepestPullbackLevel, low)
            // V7.2: Swing Respect - check if price touched protected level
            if not na(protectedLow) and low <= protectedLow
                protectedLevelTested := true
        else
            inGoldenZone := high >= currentFib50 and close <= currentFib618
            inDeepZone := high >= currentFib618 and close <= currentFib786
            // Track deepest level reached
            if high >= currentFib618
                hasEnteredDeep := true
                deepestPullbackLevel := math.max(na(deepestPullbackLevel) ? high : deepestPullbackLevel, high)
            // V7.2: Swing Respect - check if price touched protected level
            if not na(protectedHigh) and high >= protectedHigh
                protectedLevelTested := true

        // Track bars in zone
        if inGoldenZone or inDeepZone
            barsInGoldenZone += 1
        else
            barsInGoldenZone := 0
        
        // Check for confirmation
        displacementConfirmed = false
        internalBOSConfirmed = false
        zoneBreakoutConfirmed = false
        zoneConfluence = false
        
        // Displacement candle check
        candleBody = math.abs(close - open)
        if pullbackDirection == 1
            displacementConfirmed := close > open and candleBody > (atrValue * displacementATR)
        else
            displacementConfirmed := close < open and candleBody > (atrValue * displacementATR)
        
        // Internal BOS check
        if pullbackDirection == 1 and not na(internalSwingHigh)
            internalBOSConfirmed := close > internalSwingHigh
        if pullbackDirection == -1 and not na(internalSwingLow)
            internalBOSConfirmed := close < internalSwingLow
        
        // Zone Breakout check: After entering golden zone, break back above 0.5 fib with momentum
        // This catches the pattern: pullback to 0.618 â†’ consolidation â†’ break above 0.5
        if pullbackDirection == 1
            // Bullish: Was in zone, now closed above 0.5 fib with bullish candle
            zoneBreakoutConfirmed := hasEnteredDeep and close > currentFib50 and close > open and barsInGoldenZone >= minBarsInZone
        else
            // Bearish: Was in zone, now closed below 0.5 fib with bearish candle
            zoneBreakoutConfirmed := hasEnteredDeep and close < currentFib50 and close < open and barsInGoldenZone >= minBarsInZone
        
        // Zone Confluence check: Price near a demand/supply zone
        if requireZoneConfluence and array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                zone = array.get(activeZones, i)
                if pullbackDirection == 1 and not zone.isSupply and not zone.invalidated
                    // Bullish: Check if price near demand zone
                    if low <= zone.top + (atrValue * zoneProximityATR) and low >= zone.bottom - (atrValue * zoneProximityATR)
                        zoneConfluence := true
                        break
                else if pullbackDirection == -1 and zone.isSupply and not zone.invalidated
                    // Bearish: Check if price near supply zone
                    if high >= zone.bottom - (atrValue * zoneProximityATR) and high <= zone.top + (atrValue * zoneProximityATR)
                        zoneConfluence := true
                        break
        else
            zoneConfluence := true  // If not required, always true
        
        // Minimum bars requirement
        minBarsRequirementMet = barsInGoldenZone >= minBarsInZone
        
        // Determine if confirmation triggered based on settings
        confirmationMet = false
        if confirmationType == "None"
            confirmationMet := (inGoldenZone or inDeepZone) and minBarsRequirementMet
        else if confirmationType == "Displacement Candle"
            confirmationMet := (inGoldenZone or inDeepZone) and displacementConfirmed and minBarsRequirementMet
        else if confirmationType == "Internal BOS"
            confirmationMet := (inGoldenZone or inDeepZone) and internalBOSConfirmed and minBarsRequirementMet
        else if confirmationType == "Zone Breakout"
            confirmationMet := zoneBreakoutConfirmed
        else if confirmationType == "Zone Confluence"
            confirmationMet := (inGoldenZone or inDeepZone) and zoneConfluence and minBarsRequirementMet
        else if confirmationType == "Both"
            confirmationMet := zoneBreakoutConfirmed and zoneConfluence and displacementConfirmed

        // V7.2: Apply Phase 1 filters
        // Swing Respect filter - block entry if protected level was touched during pullback
        if requireSwingRespect and protectedLevelTested
            confirmationMet := false

        // Draw/update visuals
        zoneRight = bar_index + 15
        fibLineRight = bar_index + 20
        
        // Clean up old drawings first
        if not na(goldenZoneBox)
            box.delete(goldenZoneBox)
        if not na(deepZoneBox)
            box.delete(deepZoneBox)
        if not na(fib0Line)
            line.delete(fib0Line)
        if not na(fib50Line)
            line.delete(fib50Line)
        if not na(fib618Line)
            line.delete(fib618Line)
        if not na(fib786Line)
            line.delete(fib786Line)
        if not na(fib100Line)
            line.delete(fib100Line)
        if not na(fib0Label)
            label.delete(fib0Label)
        if not na(fib50Label)
            label.delete(fib50Label)
        if not na(fib618Label)
            label.delete(fib618Label)
        if not na(fib786Label)
            label.delete(fib786Label)
        if not na(fib100Label)
            label.delete(fib100Label)
        
        // Determine zone colors based on direction and state
        var color currentGoldenColor = na
        var color borderColor = na
        
        if pullbackDirection == 1
            currentGoldenColor := goldenZoneColorBull
            borderColor := color.rgb(255, 215, 0)  // Gold border for bullish
            if inGoldenZone
                currentGoldenColor := color.new(color.yellow, 70)  // Highlight when price is in zone
        else
            currentGoldenColor := goldenZoneColorBear
            borderColor := color.rgb(255, 140, 0)  // Orange border for bearish
            if inGoldenZone
                currentGoldenColor := color.new(color.orange, 70)  // Highlight when price is in zone
        
        // Draw golden zone box
        if pullbackDirection == 1
            goldenZoneBox := box.new(pullbackStartBar, currentFib50, zoneRight, currentFib618,
                                     bgcolor=currentGoldenColor,
                                     border_color=borderColor,
                                     border_width=1)
        else
            goldenZoneBox := box.new(pullbackStartBar, currentFib618, zoneRight, currentFib50,
                                     bgcolor=currentGoldenColor,
                                     border_color=borderColor,
                                     border_width=1)
        
        // Draw deep zone if enabled
        if showDeepZone
            if pullbackDirection == 1
                deepZoneBox := box.new(pullbackStartBar, currentFib618, zoneRight, currentFib786,
                                       bgcolor=deepZoneColor,
                                       border_color=color.new(color.green, 60),
                                       border_width=1,
                                       border_style=line.style_dotted)
            else
                deepZoneBox := box.new(pullbackStartBar, currentFib786, zoneRight, currentFib618,
                                       bgcolor=deepZoneColor,
                                       border_color=color.new(color.red, 60),
                                       border_width=1,
                                       border_style=line.style_dotted)
        
        // Draw fib lines if enabled
        if showFibLines
            fibColor = pullbackDirection == 1 ? bullColor : bearColor
            
            fib0Line := line.new(pullbackStartBar, currentFibOrigin, fibLineRight, currentFibOrigin,
                                 color=color.new(fibColor, 60), width=1, style=line.style_dotted)
            fib50Line := line.new(pullbackStartBar, currentFib50, fibLineRight, currentFib50,
                                  color=color.new(color.yellow, 50), width=1, style=line.style_dashed)
            fib618Line := line.new(pullbackStartBar, currentFib618, fibLineRight, currentFib618,
                                   color=color.new(color.orange, 50), width=1, style=line.style_dashed)
            fib786Line := line.new(pullbackStartBar, currentFib786, fibLineRight, currentFib786,
                                   color=color.new(color.red, 60), width=1, style=line.style_dotted)
            fib100Line := line.new(pullbackStartBar, currentFibExtreme, fibLineRight, currentFibExtreme,
                                   color=color.new(fibColor, 60), width=1, style=line.style_dotted)
            
            // Labels
            fib0Label := label.new(fibLineRight, currentFibOrigin, "0%",
                                   style=label.style_label_left, color=color.new(fibColor, 90),
                                   textcolor=fibColor, size=size.tiny)
            fib50Label := label.new(fibLineRight, currentFib50, str.tostring(fibUpperLevel * 100, "#.#") + "%",
                                    style=label.style_label_left, color=color.new(color.yellow, 90),
                                    textcolor=color.yellow, size=size.tiny)
            fib618Label := label.new(fibLineRight, currentFib618, str.tostring(fibLowerLevel * 100, "#.#") + "%",
                                     style=label.style_label_left, color=color.new(color.orange, 90),
                                     textcolor=color.orange, size=size.tiny)
            fib786Label := label.new(fibLineRight, currentFib786, str.tostring(fibDeepLevel * 100, "#.#") + "%",
                                     style=label.style_label_left, color=color.new(color.red, 90),
                                     textcolor=color.red, size=size.tiny)
            fib100Label := label.new(fibLineRight, currentFibExtreme, "100%",
                                     style=label.style_label_left, color=color.new(fibColor, 90),
                                     textcolor=fibColor, size=size.tiny)
        
        // Show entry signal when confirmation triggers
        if showConfirmationSignal and confirmationMet and not pullbackConfirmed
            pullbackConfirmed := true
            signalColor = pullbackDirection == 1 ? bullColor : bearColor
            signalText = pullbackDirection == 1 ? "â–² ENTRY" : "â–¼ ENTRY"
            signalStyle = pullbackDirection == 1 ? label.style_label_up : label.style_label_down
            signalY = pullbackDirection == 1 ? low - atrValue * 0.3 : high + atrValue * 0.3

            label.new(bar_index, signalY, signalText,
                      style=signalStyle,
                      color=signalColor,
                      textcolor=color.white,
                      size=size.normal)

            // V7.3.0: Calculate partial exit targets on entry
            if enablePartialExits
                // Calculate stop distance for R:R calculations
                if pullbackDirection == 1
                    entryStopDistance := close - protectedLow
                else
                    entryStopDistance := protectedHigh - close

                // T1 Target Calculation
                if t1TargetType == "R:R Ratio"
                    if pullbackDirection == 1
                        t1TargetPrice := close + (entryStopDistance * t1RRRatio)
                    else
                        t1TargetPrice := close - (entryStopDistance * t1RRRatio)
                else  // First Swing
                    if pullbackDirection == 1
                        t1TargetPrice := confirmedSwingHigh
                    else
                        t1TargetPrice := confirmedSwingLow

                // T2 Target Calculation
                if t2TargetType == "R:R Ratio"
                    if pullbackDirection == 1
                        t2TargetPrice := close + (entryStopDistance * t2RRRatio)
                    else
                        t2TargetPrice := close - (entryStopDistance * t2RRRatio)
                else  // BOS Swing (dynamic target)
                    t2TargetPrice := entrySwingTarget

                // T3 Trail Stop Initialization
                if t3UseTrailStop
                    if pullbackDirection == 1
                        t3TrailStopPrice := protectedLow
                    else
                        t3TrailStopPrice := protectedHigh

                // Reset exit flags
                t1ExitTriggered := false
                t2ExitTriggered := false
                t3ExitTriggered := false

                // Add pullback position to remaining (momentum may already have taken some)
                if momentumEntryTaken
                    remainingPositionPct := 100  // Now full position
                else
                    remainingPositionPct := 100

// Confirmation alert conditions
pullbackEntryLong = showPullbackZone and pullbackDirection == 1 and (inGoldenZone or inDeepZone) and not pullbackConfirmed
pullbackEntryShort = showPullbackZone and pullbackDirection == -1 and (inGoldenZone or inDeepZone) and not pullbackConfirmed

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ EXIT SIGNALS (PHASE 2) â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Declare exit condition variables
var bool exitTargetReached = false
var bool exitMomentumLoss = false
var bool exitStructureFlip = false
var bool exitConsolidationAtTarget = false
var bool exitReversalCandle = false
// Note: reversalCandleExitLevel, reversalCandleDetected moved to structure section (lines 350-351)

if showExitSignals and entryConfirmed and not exitSignalShown
    // Exit Condition 1: Target Reached (price hits prior swing)
    exitTargetReached := false
    if exitOnSwingHigh and not na(entrySwingTarget)
        if pullbackDirection == 1 and close >= entrySwingTarget
            exitTargetReached := true
        else if pullbackDirection == -1 and close <= entrySwingTarget
            exitTargetReached := true
    
    // Exit Condition 2: Momentum Loss (strong counter-trend candle)
    exitMomentumLoss := false
    if exitOnMomentumLoss
        candleBody = math.abs(close - open)
        if pullbackDirection == 1 and candleBody > (atrValue * momentumLossATR) and close < open
            exitMomentumLoss := true  // Strong bearish candle in long position
        else if pullbackDirection == -1 and candleBody > (atrValue * momentumLossATR) and close > open
            exitMomentumLoss := true  // Strong bullish candle in short position
    
    // Exit Condition 3: Structure Flip (opposite BOS occurs)
    exitStructureFlip := false
    if exitOnStructureFlip
        if pullbackDirection == 1 and bearishBOS
            exitStructureFlip := true  // Bearish BOS invalidates long
        else if pullbackDirection == -1 and bullishBOS
            exitStructureFlip := true  // Bullish BOS invalidates short
    
    // Exit Condition 4: Consolidation at Target
    exitConsolidationAtTarget := false
    if exitOnConsolidation and not na(entrySwingTarget)
        // Check if price is near the target
        priceNearTarget = false
        proximityThreshold = atrValue * 0.5  // Within 0.5 ATR of target
        
        if pullbackDirection == 1
            // Long: Check if price near prior swing high
            priceNearTarget := high >= (entrySwingTarget - proximityThreshold) and low <= (entrySwingTarget + proximityThreshold)
        else if pullbackDirection == -1
            // Short: Check if price near prior swing low
            priceNearTarget := low <= (entrySwingTarget + proximityThreshold) and high >= (entrySwingTarget - proximityThreshold)
        
        // Count bars near target
        if priceNearTarget
            barsNearTarget += 1
        else
            barsNearTarget := 0
        
        // Check if consolidating (tight range for multiple bars)
        if barsNearTarget >= consolidationExitBars
            // Measure range over consolidation period
            safeLookback = math.min(barsNearTarget, bar_index)
            consolidationHigh = ta.highest(high, safeLookback)
            consolidationLow = ta.lowest(low, safeLookback)
            consolidationRange = consolidationHigh - consolidationLow
            
            // If range is tight (< consolidationExitATR * ATR), it's consolidation
            if consolidationRange <= (atrValue * consolidationExitATR)
                exitConsolidationAtTarget := true
    else
        barsNearTarget := 0

    // Exit Condition 5: Reversal Candle (hammer for short, shooting star for long)
    exitReversalCandle := false
    if exitOnReversalCandle
        candleBody = math.abs(close - open)
        upperWick = high - math.max(close, open)
        lowerWick = math.min(close, open) - low

        // Minimum body size to avoid doji confusion (at least 10% of ATR)
        minBodySize = atrValue * 0.1
        hasValidBody = candleBody >= minBodySize

        if pullbackDirection == -1  // SHORT position - look for hammer (bullish reversal)
            // Hammer: long lower wick, small upper wick, body near top
            isHammer = hasValidBody and lowerWick >= (candleBody * reversalWickMultiplier) and upperWick <= candleBody
            if isHammer and not reversalCandleDetected
                reversalCandleDetected := true
                reversalCandleExitLevel := high  // Exit when price gets back above hammer high
            // Check if price hit the exit level
            if reversalCandleDetected and not na(reversalCandleExitLevel) and close > reversalCandleExitLevel
                exitReversalCandle := true

        else if pullbackDirection == 1  // LONG position - look for shooting star (bearish reversal)
            // Shooting star: long upper wick, small lower wick, body near bottom
            isShootingStar = hasValidBody and upperWick >= (candleBody * reversalWickMultiplier) and lowerWick <= candleBody
            if isShootingStar and not reversalCandleDetected
                reversalCandleDetected := true
                reversalCandleExitLevel := low  // Exit when price gets back below shooting star low
            // Check if price hit the exit level
            if reversalCandleDetected and not na(reversalCandleExitLevel) and close < reversalCandleExitLevel
                exitReversalCandle := true

    // Trigger exit label on first condition met
    if exitTargetReached and not exitSignalShown
        exitSignalShown := true
        exitColor = pullbackDirection == 1 ? bullColor : bearColor
        exitY = pullbackDirection == 1 ? high + atrValue * 0.3 : low - atrValue * 0.3
        label.new(bar_index, exitY, (pullbackDirection == 1 ? "â–¼" : "â–²") + " EXIT\nTARGET",
                  style=pullbackDirection == 1 ? label.style_label_down : label.style_label_up,
                  color=exitColor,
                  textcolor=color.white,
                  size=size.normal)
    else if exitMomentumLoss and not exitSignalShown
        exitSignalShown := true
        exitColor = pullbackDirection == 1 ? bearColor : bullColor
        exitY = pullbackDirection == 1 ? high + atrValue * 0.3 : low - atrValue * 0.3
        label.new(bar_index, exitY, (pullbackDirection == 1 ? "â–¼" : "â–²") + " EXIT\nMOMENTUM",
                  style=pullbackDirection == 1 ? label.style_label_down : label.style_label_up,
                  color=exitColor,
                  textcolor=color.white,
                  size=size.normal)
    else if exitStructureFlip and not exitSignalShown
        exitSignalShown := true
        exitColor = pullbackDirection == 1 ? bearColor : bullColor
        exitY = pullbackDirection == 1 ? high + atrValue * 0.3 : low - atrValue * 0.3
        label.new(bar_index, exitY, (pullbackDirection == 1 ? "â–¼" : "â–²") + " EXIT\nFLIP",
                  style=pullbackDirection == 1 ? label.style_label_down : label.style_label_up,
                  color=exitColor,
                  textcolor=color.white,
                  size=size.normal)
    else if exitConsolidationAtTarget and not exitSignalShown
        exitSignalShown := true
        exitColor = color.orange
        exitY = pullbackDirection == 1 ? high + atrValue * 0.3 : low - atrValue * 0.3
        label.new(bar_index, exitY, (pullbackDirection == 1 ? "â–¼" : "â–²") + " EXIT\nCONSOL",
                  style=pullbackDirection == 1 ? label.style_label_down : label.style_label_up,
                  color=exitColor,
                  textcolor=color.white,
                  size=size.normal)
    else if exitReversalCandle and not exitSignalShown
        exitSignalShown := true
        exitColor = color.purple
        exitY = pullbackDirection == 1 ? high + atrValue * 0.3 : low - atrValue * 0.3
        label.new(bar_index, exitY, (pullbackDirection == 1 ? "â–¼" : "â–²") + " EXIT\nREVERSAL",
                  style=pullbackDirection == 1 ? label.style_label_down : label.style_label_up,
                  color=exitColor,
                  textcolor=color.white,
                  size=size.normal)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ V7.3.0: Partial Exit System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if enablePartialExits and entryConfirmed and remainingPositionPct > 0

    // T1 Exit Check (first tier)
    if not t1ExitTriggered and not na(t1TargetPrice)
        t1Reached = false
        if pullbackDirection == 1 and high >= t1TargetPrice
            t1Reached := true
        else if pullbackDirection == -1 and low <= t1TargetPrice
            t1Reached := true

        if t1Reached
            t1ExitTriggered := true
            remainingPositionPct -= t1PositionPct

            // T1 Exit Label
            exitColor = color.rgb(0, 200, 83)  // Green for profit
            exitY = pullbackDirection == 1 ? high + atrValue * 0.3 : low - atrValue * 0.3
            label.new(bar_index, exitY,
                (pullbackDirection == 1 ? "â–¼" : "â–²") + " T1\n" + str.tostring(t1PositionPct) + "%",
                style=pullbackDirection == 1 ? label.style_label_down : label.style_label_up,
                color=exitColor,
                textcolor=color.white,
                size=size.normal)

    // T2 Exit Check (second tier - after T1)
    if t1ExitTriggered and not t2ExitTriggered and not na(t2TargetPrice)
        t2Reached = false
        if pullbackDirection == 1 and high >= t2TargetPrice
            t2Reached := true
        else if pullbackDirection == -1 and low <= t2TargetPrice
            t2Reached := true

        if t2Reached
            t2ExitTriggered := true
            remainingPositionPct -= t2PositionPct

            // T2 Exit Label
            exitColor = color.rgb(0, 200, 83)
            exitY = pullbackDirection == 1 ? high + atrValue * 0.3 : low - atrValue * 0.3
            label.new(bar_index, exitY,
                (pullbackDirection == 1 ? "â–¼" : "â–²") + " T2\n" + str.tostring(t2PositionPct) + "%",
                style=pullbackDirection == 1 ? label.style_label_down : label.style_label_up,
                color=exitColor,
                textcolor=color.white,
                size=size.normal)

    // T3 Exit Check (runner with trail stop - after T2)
    if t2ExitTriggered and not t3ExitTriggered
        // Update trail stop
        if t3UseTrailStop
            if t3TrailMethod == "Swing Levels"
                // Trail stop at swing levels
                if pullbackDirection == 1 and not na(swingLow)
                    // Trail up below new Higher Lows
                    if swingLow > t3TrailStopPrice or na(t3TrailStopPrice)
                        t3TrailStopPrice := swingLow
                else if pullbackDirection == -1 and not na(swingHigh)
                    // Trail down above new Lower Highs
                    if swingHigh < t3TrailStopPrice or na(t3TrailStopPrice)
                        t3TrailStopPrice := swingHigh
            else  // ATR Distance method
                if pullbackDirection == 1
                    newTrail = high - (atrValue * t3ATRMultiple)
                    if newTrail > t3TrailStopPrice or na(t3TrailStopPrice)
                        t3TrailStopPrice := newTrail
                else
                    newTrail = low + (atrValue * t3ATRMultiple)
                    if newTrail < t3TrailStopPrice or na(t3TrailStopPrice)
                        t3TrailStopPrice := newTrail

        // Check if trail stop hit
        t3StopHit = false
        if not na(t3TrailStopPrice)
            if pullbackDirection == 1 and close < t3TrailStopPrice
                t3StopHit := true
            else if pullbackDirection == -1 and close > t3TrailStopPrice
                t3StopHit := true

        // Check for structure flip (also exits T3)
        if (pullbackDirection == 1 and bearishBOS) or (pullbackDirection == -1 and bullishBOS)
            t3StopHit := true

        if t3StopHit
            t3ExitTriggered := true
            remainingPositionPct -= t3PositionPct

            // T3 Exit Label
            exitColor = color.orange
            exitY = pullbackDirection == 1 ? low - atrValue * 0.3 : high + atrValue * 0.3
            label.new(bar_index, exitY,
                (pullbackDirection == 1 ? "â–¼" : "â–²") + " T3\n" + str.tostring(t3PositionPct) + "%",
                style=pullbackDirection == 1 ? label.style_label_down : label.style_label_up,
                color=exitColor,
                textcolor=color.white,
                size=size.normal)

// Draw/update target lines for partial exits
if enablePartialExits and showTargetLines and entryConfirmed
    lineColor = pullbackDirection == 1 ? bullColor : bearColor

    // T1 Target Line
    if not t1ExitTriggered and not na(t1TargetPrice)
        if na(t1TargetLine)
            t1TargetLine := line.new(bar_index - 5, t1TargetPrice, bar_index + 10, t1TargetPrice,
                color=color.new(lineColor, 60), width=1, style=line.style_dashed)
        else
            line.set_x2(t1TargetLine, bar_index + 10)
    else if not na(t1TargetLine)
        line.delete(t1TargetLine)
        t1TargetLine := na

    // T2 Target Line
    if t1ExitTriggered and not t2ExitTriggered and not na(t2TargetPrice)
        if na(t2TargetLine)
            t2TargetLine := line.new(bar_index - 5, t2TargetPrice, bar_index + 10, t2TargetPrice,
                color=color.new(lineColor, 40), width=1, style=line.style_dashed)
        else
            line.set_x2(t2TargetLine, bar_index + 10)
    else if not na(t2TargetLine)
        line.delete(t2TargetLine)
        t2TargetLine := na

    // T3 Trail Stop Line
    if showTrailStopLine and t2ExitTriggered and not t3ExitTriggered and not na(t3TrailStopPrice)
        trailColor = pullbackDirection == 1 ? bearColor : bullColor
        if na(t3TrailLine)
            t3TrailLine := line.new(bar_index - 5, t3TrailStopPrice, bar_index + 10, t3TrailStopPrice,
                color=color.new(trailColor, 50), width=2, style=line.style_solid)
        else
            line.set_x1(t3TrailLine, bar_index - 5)
            line.set_x2(t3TrailLine, bar_index + 10)
            line.set_y1(t3TrailLine, t3TrailStopPrice)
            line.set_y2(t3TrailLine, t3TrailStopPrice)
    else if not na(t3TrailLine)
        line.delete(t3TrailLine)
        t3TrailLine := na

// Exit alert conditions
exitLongTarget = showExitSignals and pullbackDirection == 1 and exitTargetReached and not exitSignalShown
exitLongMomentum = showExitSignals and pullbackDirection == 1 and exitMomentumLoss and not exitSignalShown
exitLongFlip = showExitSignals and pullbackDirection == 1 and exitStructureFlip and not exitSignalShown
exitLongConsol = showExitSignals and pullbackDirection == 1 and exitConsolidationAtTarget and not exitSignalShown
exitLongReversal = showExitSignals and pullbackDirection == 1 and exitReversalCandle and not exitSignalShown
exitShortTarget = showExitSignals and pullbackDirection == -1 and exitTargetReached and not exitSignalShown
exitShortMomentum = showExitSignals and pullbackDirection == -1 and exitMomentumLoss and not exitSignalShown
exitShortFlip = showExitSignals and pullbackDirection == -1 and exitStructureFlip and not exitSignalShown
exitShortConsol = showExitSignals and pullbackDirection == -1 and exitConsolidationAtTarget and not exitSignalShown
exitShortReversal = showExitSignals and pullbackDirection == -1 and exitReversalCandle and not exitSignalShown

alertcondition(exitLongTarget, title="Exit Long - Target", message="Exit Long - Target reached on {{ticker}} {{interval}}")
alertcondition(exitLongMomentum, title="Exit Long - Momentum", message="Exit Long - Momentum loss on {{ticker}} {{interval}}")
alertcondition(exitLongFlip, title="Exit Long - Structure Flip", message="Exit Long - Structure flipped on {{ticker}} {{interval}}")
alertcondition(exitLongConsol, title="Exit Long - Consolidation", message="Exit Long - Consolidation at target on {{ticker}} {{interval}}")
alertcondition(exitLongReversal, title="Exit Long - Reversal Candle", message="Exit Long - Reversal candle detected on {{ticker}} {{interval}}")
alertcondition(exitShortTarget, title="Exit Short - Target", message="Exit Short - Target reached on {{ticker}} {{interval}}")
alertcondition(exitShortMomentum, title="Exit Short - Momentum", message="Exit Short - Momentum loss on {{ticker}} {{interval}}")
alertcondition(exitShortFlip, title="Exit Short - Structure Flip", message="Exit Short - Structure flipped on {{ticker}} {{interval}}")
alertcondition(exitShortConsol, title="Exit Short - Consolidation", message="Exit Short - Consolidation at target on {{ticker}} {{interval}}")
alertcondition(exitShortReversal, title="Exit Short - Reversal Candle", message="Exit Short - Reversal candle detected on {{ticker}} {{interval}}")

// V7.3.0: Momentum Entry Alerts
momentumEntryLong = enableMomentumEntry and bullishBOS and momentumEntryTaken and bar_index == momentumEntryBar
momentumEntryShort = enableMomentumEntry and bearishBOS and momentumEntryTaken and bar_index == momentumEntryBar

alertcondition(momentumEntryLong, title="Momentum Entry - Long", message="âš¡ Momentum Entry LONG on {{ticker}} {{interval}}")
alertcondition(momentumEntryShort, title="Momentum Entry - Short", message="âš¡ Momentum Entry SHORT on {{ticker}} {{interval}}")

// V7.3.0: Partial Exit Alerts
exitT1Long = enablePartialExits and pullbackDirection == 1 and t1ExitTriggered and not t2ExitTriggered
exitT1Short = enablePartialExits and pullbackDirection == -1 and t1ExitTriggered and not t2ExitTriggered
exitT2Long = enablePartialExits and pullbackDirection == 1 and t2ExitTriggered and not t3ExitTriggered
exitT2Short = enablePartialExits and pullbackDirection == -1 and t2ExitTriggered and not t3ExitTriggered
exitT3Long = enablePartialExits and pullbackDirection == 1 and t3ExitTriggered
exitT3Short = enablePartialExits and pullbackDirection == -1 and t3ExitTriggered

alertcondition(exitT1Long, title="Exit T1 - Long", message="EXIT T1 LONG on {{ticker}} {{interval}}")
alertcondition(exitT1Short, title="Exit T1 - Short", message="EXIT T1 SHORT on {{ticker}} {{interval}}")
alertcondition(exitT2Long, title="Exit T2 - Long", message="EXIT T2 LONG on {{ticker}} {{interval}}")
alertcondition(exitT2Short, title="Exit T2 - Short", message="EXIT T2 SHORT on {{ticker}} {{interval}}")
alertcondition(exitT3Long, title="Exit T3 - Long", message="EXIT T3 LONG on {{ticker}} {{interval}}")
alertcondition(exitT3Short, title="Exit T3 - Short", message="EXIT T3 SHORT on {{ticker}} {{interval}}")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ DASHBOARD â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showDashboard
    var string dashX = dashboardPosition == "Top Left" or dashboardPosition == "Bottom Left" ? position.top_left : position.top_right
    var string dashY = dashboardPosition == "Bottom Left" or dashboardPosition == "Bottom Right" ? position.bottom_left : dashX
    
    // Compact table - 7 rows instead of 11
    var table dashboard = table.new(dashY, 2, 7, border_width=1)
    
    // Structure state text
    stateText = structureState == 1 ? "BULL" : (structureState == -1 ? "BEAR" : "RANGE")
    stateColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
    
    // BOS strength
    bosStrengthText = lastBOSStrong ? "S" : "W"
    bosStrengthColor = lastBOSStrong ? strongBOSColor : weakBOSColor
    
    // Protected level display (shortened)
    var string protectedText = "-"
    if structureState == 1
        protectedText := str.tostring(protectedLow, format.mintick)
    else if structureState == -1
        protectedText := str.tostring(protectedHigh, format.mintick)
    else
        protectedText := "-"
    
    // Pullback Zone Status (shortened) - V7.3.0: Enhanced with momentum/partial exits
    var string pullbackStatus = "-"
    var color pullbackStatusColor = color.gray

    // Track bars since entry confirmed for status transitions
    if pullbackConfirmed and not entryConfirmed
        entryConfirmed := true
        entryBar := bar_index
        barsForGoStatus := 0

    if entryConfirmed and not na(entryBar)
        barsForGoStatus := bar_index - entryBar

    // V7.3.0: Enhanced status progression with partial exits
    if pullbackDirection != 0
        dirArrow = pullbackDirection == 1 ? "â–²" : "â–¼"
        dirColor = pullbackDirection == 1 ? bullColor : bearColor

        // Check partial exit status first
        if enablePartialExits and entryConfirmed
            if t3ExitTriggered
                pullbackStatus := "DONE" + dirArrow
                pullbackStatusColor := color.gray
            else if t2ExitTriggered
                pullbackStatus := "T3 " + str.tostring(remainingPositionPct) + "%"
                pullbackStatusColor := color.orange
            else if t1ExitTriggered
                pullbackStatus := "T2 " + str.tostring(remainingPositionPct) + "%"
                pullbackStatusColor := dirColor
            else
                pullbackStatus := "T1 " + str.tostring(remainingPositionPct) + "%"
                pullbackStatusColor := dirColor
        else if momentumEntryTaken and not entryConfirmed
            // Momentum entry only (waiting for pullback)
            pullbackStatus := "MOM " + str.tostring(momentumPositionSize) + "%"
            pullbackStatusColor := color.rgb(255, 215, 0)  // Gold
        else if entryConfirmed and barsForGoStatus < 3
            pullbackStatus := "GO" + dirArrow
            pullbackStatusColor := dirColor
        else if entryConfirmed and barsForGoStatus >= 3
            pullbackStatus := "DONE" + dirArrow
            pullbackStatusColor := color.gray
        else if pullbackConfirmed
            pullbackStatus := "RDY" + dirArrow
            pullbackStatusColor := color.orange
        else if hasEnteredDeep and barsInGoldenZone >= minBarsInZone
            pullbackStatus := "RDY" + dirArrow
            pullbackStatusColor := color.orange
        else if inGoldenZone or inDeepZone
            pullbackStatus := "IN" + dirArrow
            pullbackStatusColor := color.lime
        else
            pullbackStatus := "WAIT" + dirArrow
            pullbackStatusColor := color.yellow
    else
        // Reset entry tracking when pullback direction changes
        if entryConfirmed
            entryConfirmed := false
            entryBar := na
            barsForGoStatus := 0
        pullbackStatus := "-"
        pullbackStatusColor := color.gray
    
    // Row 0: Structure state (header)
    table.cell(dashboard, 0, 0, stateText, text_color=stateColor, bgcolor=color.new(stateColor, 85), text_size=size.normal)
    table.cell(dashboard, 1, 0, timeframe.period + " | " + str.tostring(swingLength), text_color=color.orange, bgcolor=color.new(color.gray, 85), text_size=size.normal)
    
    // Row 1: Swing levels combined
    table.cell(dashboard, 0, 1, "H " + str.tostring(confirmedSwingHigh, format.mintick), text_color=bearColor, text_size=size.normal)
    table.cell(dashboard, 1, 1, "L " + str.tostring(confirmedSwingLow, format.mintick), text_color=bullColor, text_size=size.normal)
    
    // Row 2: Protected level
    table.cell(dashboard, 0, 2, "Prot", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 2, protectedText, text_color=stateColor, text_size=size.normal)
    
    // Row 3: BOS strength + bars since
    table.cell(dashboard, 0, 3, "BOS", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 3, bosStrengthText + " | " + str.tostring(barsSinceImpulse) + "b", text_color=bosStrengthColor, text_size=size.normal)
    
    // Row 4: Active zones
    activeZoneCount = array.size(activeZones)
    table.cell(dashboard, 0, 4, "S/D", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 4, str.tostring(activeZoneCount), text_color=color.white, text_size=size.normal)
    
    // Row 5: Pullback status
    table.cell(dashboard, 0, 5, "Entry", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 5, pullbackStatus, text_color=pullbackStatusColor, text_size=size.normal)
    
    // Row 6: Auto-TF indicator
    autoTFText = useAutoTF ? "Auto" : "Manual"
    table.cell(dashboard, 0, 6, "TF", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 6, autoTFText, text_color=useAutoTF ? color.green : color.gray, text_size=size.normal)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ ALERTS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// BOS Alerts (with strength)
alertcondition(bullishBOS and bosIsStrong, title="Strong Bullish BOS", message="Strong Bullish Break of Structure on {{ticker}} {{interval}}")
alertcondition(bullishBOS and not bosIsStrong, title="Weak Bullish BOS", message="Weak Bullish Break of Structure on {{ticker}} {{interval}}")
alertcondition(bearishBOS and bosIsStrong, title="Strong Bearish BOS", message="Strong Bearish Break of Structure on {{ticker}} {{interval}}")
alertcondition(bearishBOS and not bosIsStrong, title="Weak Bearish BOS", message="Weak Bearish Break of Structure on {{ticker}} {{interval}}")

// Standard BOS Alerts
alertcondition(bullishBOS, title="Bullish BOS", message="Bullish Break of Structure detected on {{ticker}} {{interval}}")
alertcondition(bearishBOS, title="Bearish BOS", message="Bearish Break of Structure detected on {{ticker}} {{interval}}")

// Structure Change Alerts
structureFlipped = structureState != prevStructureState and prevStructureState != 0
alertcondition(structureFlipped and structureState == 1, title="Structure Flip Bullish", message="Structure flipped from Bearish to Bullish on {{ticker}} {{interval}}")
alertcondition(structureFlipped and structureState == -1, title="Structure Flip Bearish", message="Structure flipped from Bullish to Bearish on {{ticker}} {{interval}}")
alertcondition(structureFlipped and structureState == 0, title="Entered Consolidation", message="Market entered consolidation on {{ticker}} {{interval}}")

// Protected Level Alerts
alertcondition(protectedLevelBroken and structureState == 1, title="Protected Low Broken", message="Protected Low broken - structure shift on {{ticker}} {{interval}}")
alertcondition(protectedLevelBroken and structureState == -1, title="Protected High Broken", message="Protected High broken - structure shift on {{ticker}} {{interval}}")

// Internal Break / Trap Alerts
alertcondition(internalBullBreak, title="Internal Bull Break (Trap Warning)", message="Internal bullish break detected - possible trap on {{ticker}} {{interval}}")
alertcondition(internalBearBreak, title="Internal Bear Break (Trap Warning)", message="Internal bearish break detected - possible trap on {{ticker}} {{interval}}")

// Liquidity Sweep Alerts
alertcondition(bullSweep, title="Bullish Sweep", message="Liquidity Sweep above swing high on {{ticker}} {{interval}}")
alertcondition(bearSweep, title="Bearish Sweep", message="Liquidity Sweep below swing low on {{ticker}} {{interval}}")

// Pullback Entry Alerts
alertcondition(pullbackEntryLong, title="Pullback Entry Long", message="Price in golden zone for LONG entry on {{ticker}} {{interval}}")
alertcondition(pullbackEntryShort, title="Pullback Entry Short", message="Price in golden zone for SHORT entry on {{ticker}} {{interval}}")
alertcondition(pullbackEntryLong and pullbackConfirmed, title="Confirmed Long Entry", message="CONFIRMED Long entry signal in golden zone on {{ticker}} {{interval}}")
alertcondition(pullbackEntryShort and pullbackConfirmed, title="Confirmed Short Entry", message="CONFIRMED Short entry signal in golden zone on {{ticker}} {{interval}}")

// Exit Alerts (Phase 2)
alertcondition(exitLongTarget, title="Exit Long - Target Reached", message="LONG EXIT: Price reached target (prior swing high) on {{ticker}} {{interval}}")
alertcondition(exitLongMomentum, title="Exit Long - Momentum Loss", message="LONG EXIT: Strong momentum loss (counter-trend candle) on {{ticker}} {{interval}}")
alertcondition(exitLongFlip, title="Exit Long - Structure Flip", message="LONG EXIT: Structure flipped to bearish on {{ticker}} {{interval}}")
alertcondition(exitShortTarget, title="Exit Short - Target Reached", message="SHORT EXIT: Price reached target (prior swing low) on {{ticker}} {{interval}}")
alertcondition(exitShortMomentum, title="Exit Short - Momentum Loss", message="SHORT EXIT: Strong momentum loss (counter-trend candle) on {{ticker}} {{interval}}")
alertcondition(exitShortFlip, title="Exit Short - Structure Flip", message="SHORT EXIT: Structure flipped to bullish on {{ticker}} {{interval}}")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ PLOTS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Background color based on structure (subtle)
bgColor = structureState == 1 ? color.new(bullColor, 97) : (structureState == -1 ? color.new(bearColor, 97) : color.new(neutralColor, 98))
bgcolor(bgColor, title="Structure Background")

// Plot swing levels as reference
plot(confirmedSwingHigh, "Swing High", color=color.new(bearColor, 70), style=plot.style_circles, linewidth=1, display=display.none)
plot(confirmedSwingLow, "Swing Low", color=color.new(bullColor, 70), style=plot.style_circles, linewidth=1, display=display.none)

// Plot protected levels for external use
plot(useProtectedLevels and structureState == 1 ? protectedLow : na, "Protected Low", color=color.new(bullColor, 50), style=plot.style_linebr, linewidth=1, display=display.none)
plot(useProtectedLevels and structureState == -1 ? protectedHigh : na, "Protected High", color=color.new(bearColor, 50), style=plot.style_linebr, linewidth=1, display=display.none)

// Plot impulse range for external use
plot(useInternalFilter ? impulseHigh : na, "Impulse High", color=color.new(color.purple, 70), style=plot.style_linebr, linewidth=1, display=display.none)
plot(useInternalFilter ? impulseLow : na, "Impulse Low", color=color.new(color.purple, 70), style=plot.style_linebr, linewidth=1, display=display.none)
