// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© SSOF - Smart Structure & Order Flow
// GitHub: https://github.com/d1360tx/tradingview-ssof-indicator

//@version=6
indicator("Smart Structure & Order Flow [SSOF] V7.0.1-alpha", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ INPUTS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Auto-Timeframe Settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpAutoTF = "ğŸ• Auto-Timeframe Adjustment"
useAutoTF = input.bool(true, "Enable Auto Timeframe Adjustment?", group=grpAutoTF, tooltip="Automatically adjust swing length based on current timeframe")
tf1m = input.int(3, "1m Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf5m = input.int(5, "5m Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf15m = input.int(7, "15m Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf30m = input.int(5, "30m Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf1h = input.int(10, "1H Swing Length", minval=1, maxval=50, group=grpAutoTF)
tf4h = input.int(15, "4H Swing Length", minval=1, maxval=50, group=grpAutoTF)
tfD = input.int(20, "Daily Swing Length", minval=1, maxval=50, group=grpAutoTF)
tfW = input.int(25, "Weekly Swing Length", minval=1, maxval=50, group=grpAutoTF)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Structure Settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpStructure = "âš™ï¸ Structure Settings"
manualSwingLength = input.int(5, "Manual Swing Length", minval=1, maxval=50, group=grpStructure, tooltip="Used when Auto-TF is disabled")
showInternalStructure = input.bool(false, "Show Internal Structure?", group=grpStructure, tooltip="Show minor pivots within the major trend")
internalLength = input.int(3, "Internal Lookback Length", minval=1, maxval=20, group=grpStructure, tooltip="Lookback for internal structure pivots")
showLiqSweeps = input.bool(true, "Show Liquidity Sweeps?", group=grpStructure, tooltip="Mark when price sweeps a level but closes back inside")
showDevelopingLevels = input.bool(true, "Show Developing BOS Levels?", group=grpStructure, tooltip="Show dashed lines at swing levels before BOS confirmation")
showZigZag = input.bool(true, "Show Zig-Zag Path?", group=grpStructure, tooltip="Connect swing points with trend-colored lines")
maxZigZagLines = input.int(50, "Max Zig-Zag Lines", minval=1, maxval=100, group=grpStructure, tooltip="Number of recent zig-zag connections to display")
showLabels = input.bool(true, "Show HH/HL/LH/LL Labels?", group=grpStructure)
showDashboard = input.bool(true, "Show Trend Dashboard?", group=grpStructure)
dashboardPosition = input.string("Top Right", "Dashboard Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group=grpStructure)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Protected Levels (A4) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpProtected = "ğŸ›¡ï¸ Protected Levels (Structure Anchors)"
useProtectedLevels = input.bool(true, "Enable Protected Levels?", group=grpProtected, tooltip="Structure only invalidates when protected level breaks, not every swing")
protectedLookback = input.int(2, "Protected Level Lookback (x Swing Length)", minval=1, maxval=5, group=grpProtected, tooltip="Multiplier of swing length to find origin low/high")
showProtectedLines = input.bool(true, "Show Protected Level Lines?", group=grpProtected, tooltip="Draw horizontal lines at protected levels")
protectedLineStyle = input.string("Dashed", "Protected Line Style", options=["Solid", "Dashed", "Dotted"], group=grpProtected)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal Structure Filter (A5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpInternal = "ğŸ” Internal Structure Filter"
useInternalFilter = input.bool(true, "Filter Internal Breaks?", group=grpInternal, tooltip="Ignore breaks that happen inside the last impulse range")
showInternalBreaks = input.bool(false, "Show Internal Break Labels?", group=grpInternal, tooltip="Mark internal breaks that don't flip trend")
showTrapWarnings = input.bool(true, "Show Trap Warnings?", group=grpInternal, tooltip="Alert when price breaks internal level but stays in range")
showInternalZones = input.bool(false, "Show Internal Structure Zones?", group=grpInternal, tooltip="Create supply/demand zones at internal breaks (dimmer styling). Useful for reference but not true BOS zones.")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Consolidation Detection (A1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpConsolidation = "ğŸ“Š Consolidation Detection"
useConsolidation = input.bool(true, "Enable Consolidation Detection?", group=grpConsolidation, tooltip="Detect when market is range-bound")
consolidationBars = input.int(8, "Lookback Bars", minval=3, maxval=20, group=grpConsolidation, tooltip="Number of bars to analyze for consolidation range")
consolidationRangeATR = input.float(2.5, "Max Range (ATR)", minval=0.3, maxval=5.0, step=0.1, group=grpConsolidation, tooltip="Maximum range size as ATR multiple to qualify as consolidation")
minConsolidationBars = input.int(6, "Minimum Duration (bars)", minval=3, maxval=20, group=grpConsolidation, tooltip="Minimum bars price must stay in range to qualify as consolidation")
showConsolidationBox = input.bool(true, "Show Consolidation Range Box?", group=grpConsolidation, tooltip="Draw a box around the consolidation range")
showHistoricalConsolidation = input.bool(true, "Show Historical Consolidation?", group=grpConsolidation, tooltip="Keep broken consolidation zones visible (dimmed)")
maxHistoricalBoxes = input.int(5, "Max Historical Boxes", minval=1, maxval=20, group=grpConsolidation, tooltip="Number of historical consolidation boxes to keep")
consolidationColor = input.color(color.rgb(128, 128, 128, 80), "Consolidation Box Color", group=grpConsolidation)
brokenConsolidationColor = input.color(color.rgb(100, 100, 100, 90), "Broken Consolidation Color", group=grpConsolidation)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Displacement Strength (A6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpDisplacement = "ğŸ’ª Displacement Strength (BOS Quality)"
useDisplacementGrading = input.bool(true, "Grade BOS Strength?", group=grpDisplacement, tooltip="Classify BOS as Strong or Weak based on candle characteristics")
strongBOSThreshold = input.float(0.5, "Strong BOS (Body/ATR Ratio)", minval=0.1, maxval=2.0, step=0.1, group=grpDisplacement, tooltip="Body must be > this % of ATR to be strong")
showStrengthLabels = input.bool(true, "Show Strength on BOS Labels?", group=grpDisplacement, tooltip="Add (S) or (W) suffix to BOS labels")
atrPeriod = input.int(14, "ATR Period", minval=5, maxval=50, group=grpDisplacement)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Zone Settings (A7) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpZones = "ğŸ“¦ Supply & Demand Zones"
showZones = input.bool(true, "Show Supply/Demand Zones?", group=grpZones)
zoneDirectionFilter = input.bool(true, "Filter Zones by Trend?", group=grpZones, tooltip="Only show demand in bullish structure, supply in bearish")
requireFVG = input.bool(false, "Require Imbalance/FVG?", group=grpZones, tooltip="Only show zones that have FVG confirmation for higher probability")
fvgMinSize = input.float(0.5, "Min FVG Size (ATR %)", minval=0.1, maxval=5.0, step=0.1, group=grpZones, tooltip="Minimum FVG size as percentage of ATR")
removeMitigated = input.bool(true, "Remove Mitigated Zones?", group=grpZones, tooltip="Auto-delete zones that price breaks through")
zoneExtendBars = input.int(20, "Zone Extension (bars)", minval=5, maxval=100, group=grpZones)
maxZones = input.int(10, "Max Zones to Show", minval=3, maxval=50, group=grpZones)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Pullback Entry (Fib Golden Zone) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpPullback = "ğŸ“ Pullback Entry (Fib Golden Zone)"
showPullbackZone = input.bool(true, "Show Pullback Entry Zone?", group=grpPullback, tooltip="Draw fib retracement golden zone after BOS")
fibUpperLevel = input.float(0.5, "Fib Upper Level", minval=0.1, maxval=0.9, step=0.01, group=grpPullback, tooltip="Upper boundary of golden zone")
fibLowerLevel = input.float(0.618, "Fib Lower Level", minval=0.1, maxval=0.9, step=0.01, group=grpPullback, tooltip="Lower boundary of golden zone (deeper retracement)")
fibDeepLevel = input.float(0.786, "Fib Deep Level (Discount)", minval=0.5, maxval=0.95, step=0.01, group=grpPullback, tooltip="Deeper discount zone - higher risk/reward")
showDeepZone = input.bool(false, "Show Deep Discount Zone?", group=grpPullback, tooltip="Show the deeper 0.618-0.786 zone")
goldenZoneColorBull = input.color(color.rgb(255, 215, 0, 80), "Bullish Golden Zone Color", group=grpPullback)
goldenZoneColorBear = input.color(color.rgb(255, 140, 0, 80), "Bearish Golden Zone Color", group=grpPullback)
deepZoneColor = input.color(color.rgb(255, 100, 100, 85), "Deep Zone Color", group=grpPullback)
// V7.0: Removed useProtectedFibOrigin toggle - always use impulse range (impulseLow/impulseHigh)
// This ensures fibs anchor from the ACTIVE impulse leg, not old structure

// Confirmation settings
grpConfirmation = "âœ… Entry Confirmation"
confirmationType = input.string("Internal BOS", "Confirmation Type", options=["None", "Displacement Candle", "Internal BOS", "Both"], group=grpConfirmation, tooltip="How to confirm pullback is ending")
displacementATR = input.float(0.5, "Displacement Candle (Body/ATR)", minval=0.2, maxval=1.5, step=0.1, group=grpConfirmation, tooltip="Minimum candle body size as ATR ratio for displacement confirmation")
showConfirmationSignal = input.bool(true, "Show Entry Signal?", group=grpConfirmation, tooltip="Show label when confirmation triggers in golden zone")
showFibLines = input.bool(true, "Show Fib Level Lines?", group=grpConfirmation, tooltip="Draw horizontal lines at key fib levels")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Styling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
grpStyle = "ğŸ¨ Styling"
bullColor = input.color(color.rgb(0, 230, 118), "Bullish Color", group=grpStyle)
bearColor = input.color(color.rgb(255, 82, 82), "Bearish Color", group=grpStyle)
neutralColor = input.color(color.gray, "Neutral Color", group=grpStyle)
internalColor = input.color(color.rgb(255, 235, 59), "Internal Structure Color", group=grpStyle)
strongBOSColor = input.color(color.rgb(0, 255, 170), "Strong BOS Color", group=grpStyle)
weakBOSColor = input.color(color.rgb(255, 170, 100), "Weak BOS Color", group=grpStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ AUTO-TIMEFRAME DETECTION â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

currentTFMinutes = timeframe.in_seconds() / 60

var int swingLength = manualSwingLength

if useAutoTF
    if currentTFMinutes <= 1
        swingLength := tf1m
    else if currentTFMinutes <= 5
        swingLength := tf5m
    else if currentTFMinutes <= 15
        swingLength := tf15m
    else if currentTFMinutes <= 30
        swingLength := tf30m
    else if currentTFMinutes <= 60
        swingLength := tf1h
    else if currentTFMinutes <= 240
        swingLength := tf4h
    else if currentTFMinutes <= 1440
        swingLength := tfD
    else
        swingLength := tfW
else
    swingLength := manualSwingLength

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ TYPE DEFINITIONS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type Zone
    box zoneBox
    label zoneLabel
    float top
    float bottom
    int startBar
    bool isSupply
    bool tested
    bool invalidated
    bool hasFVG

type PullbackZone
    box goldenBox
    box deepBox
    line fib0Line
    line fib50Line
    line fib618Line
    line fib786Line
    line fib100Line
    label fib0Label
    label fib50Label
    label fib618Label
    label fib786Label
    label fib100Label
    float fibOrigin       // 0% level (swing low for bull, swing high for bear)
    float fibExtreme      // 100% level (swing high for bull, swing low for bear)
    float fib50Price
    float fib618Price
    float fib786Price
    int direction         // 1 = bullish, -1 = bearish
    int startBar
    bool isActive
    bool enteredZone
    bool confirmationTriggered

// Arrays
var array<line> zigZagLines = array.new<line>()
var array<Zone> activeZones = array.new<Zone>()
var PullbackZone activePullbackZone = na
var array<box> historicalConsolidationBoxes = array.new<box>()

// Arrays for tracking recent swing points (NOT USED IN V6.0 - simple range detection doesn't need swing tracking)
// var array<float> recentSwingHighs = array.new<float>()
// var array<float> recentSwingLows = array.new<float>()
// var array<int> recentSwingHighBars = array.new<int>()
// var array<int> recentSwingLowBars = array.new<int>()
// var int maxSwingsToTrack = 10

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ HELPER FUNCTIONS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bodyClosesAbove(level) =>
    close > level and close[1] <= level

bodyClosesBelow(level) =>
    close < level and close[1] >= level

detectBullishFVG(lookback) =>
    result = false
    for i = 1 to lookback
        if low[i-1] > high[i+1]
            result := true
            break
    result

detectBearishFVG(lookback) =>
    result = false
    for i = 1 to lookback
        if high[i-1] < low[i+1]
            result := true
            break
    result

getLineStyle(styleStr) =>
    switch styleStr
        "Solid" => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted
        => line.style_dashed

// V6.0: Helper functions below not used in simple range detection
// Check if swings in array are clustered in TIME (within maxBarSpread bars of each other)
// isTimesClustered(barArray, maxBarSpread) =>
//     if array.size(barArray) < 2
//         false
//     else
//         oldestBar = array.min(barArray)
//         newestBar = array.max(barArray)
//         barSpan = newestBar - oldestBar
//         barSpan <= maxBarSpread

// Check if there's ATR compression (volatility decreasing)
// isATRCompressed(currentATR, lookback, compressionRatio) =>
//     avgATR = ta.sma(currentATR, lookback)
//     currentATR < (avgATR * compressionRatio)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ PIVOT DETECTION â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Main Swing Structure
swingHigh = ta.pivothigh(high, swingLength, swingLength)
swingLow = ta.pivotlow(low, swingLength, swingLength)

// Internal Structure
internalHigh = ta.pivothigh(high, internalLength, internalLength)
internalLow = ta.pivotlow(low, internalLength, internalLength)

// ATR for displacement grading and zone sizing
atrValue = ta.atr(atrPeriod)

// Track confirmed levels
var float confirmedSwingHigh = na
var float confirmedSwingLow = na
var int confirmedHighBar = na
var int confirmedLowBar = na

var float prevSwingHigh = na
var float prevSwingLow = na
var int prevHighBar = na
var int prevLowBar = na

// V7.0: Track the opposite swing that existed when each swing was confirmed
// This is the correct impulse origin for BOS detection
var float swingLowAtHighConfirm = na   // The swing low when this high was confirmed
var float swingHighAtLowConfirm = na   // The swing high when this low was confirmed
var int swingLowBarAtHighConfirm = na
var int swingHighBarAtLowConfirm = na

// Update swing highs
if not na(swingHigh)
    prevSwingHigh := confirmedSwingHigh
    prevHighBar := confirmedHighBar
    confirmedSwingHigh := swingHigh
    confirmedHighBar := bar_index - swingLength
    // Capture the swing low that exists NOW (origin of the impulse to this high)
    swingLowAtHighConfirm := confirmedSwingLow
    swingLowBarAtHighConfirm := confirmedLowBar

// Update swing lows
if not na(swingLow)
    prevSwingLow := confirmedSwingLow
    prevLowBar := confirmedLowBar
    confirmedSwingLow := swingLow
    confirmedLowBar := bar_index - swingLength
    // Capture the swing high that exists NOW (origin of the impulse to this low)
    swingHighAtLowConfirm := confirmedSwingHigh
    swingHighBarAtLowConfirm := confirmedHighBar

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ MARKET STRUCTURE LOGIC â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Structure State: 1 = bullish, -1 = bearish, 0 = consolidating
var int structureState = 0
var int prevStructureState = 0

// Protected Levels (A4)
var float protectedLow = na
var float protectedHigh = na
var int protectedLowBar = na
var int protectedHighBar = na

// Impulse Range (A5)
var float impulseHigh = na
var float impulseLow = na
var int lastImpulseBar = na

// Consolidation tracking (A1)
var int barsSinceImpulse = 0
var float consolidationRangeHigh = na
var float consolidationRangeLow = na
var int actualConsolidationStart = na  // Track when consolidation actually began
var int barsInTightRange = 0
var bool isConsolidating = false
var bool isRangeTight = false
var box consolidationBox = na

// BOS Strength tracking
var bool lastBOSStrong = false

// Raw BOS detection (before filters)
// Standard: Crossover above/below swing level
rawBullishBOS = not na(confirmedSwingHigh) and bodyClosesAbove(confirmedSwingHigh) and close[1] <= confirmedSwingHigh
rawBearishBOS = not na(confirmedSwingLow) and bodyClosesBelow(confirmedSwingLow) and close[1] >= confirmedSwingLow

// V7.0 FIX: Immediate continuation BOS for strong trending markets
// Problem: In strong trends, by the time a swing is confirmed (swingLength bars later),
// price is already way beyond it, so the crossover condition never triggers.
// Solution: If we're already in bullish/bearish structure AND a new swing high/low just
// got confirmed AND price is already above/below it, that's an immediate continuation BOS.

// New swing high just confirmed AND we're already bullish AND price is above it
trendContinuationBull = not na(swingHigh) and structureState == 1 and close > swingHigh
// New swing low just confirmed AND we're already bearish AND price is below it  
trendContinuationBear = not na(swingLow) and structureState == -1 and close < swingLow

// Combine: Either standard crossover OR immediate trend continuation
rawBullishBOS := rawBullishBOS or trendContinuationBull
rawBearishBOS := rawBearishBOS or trendContinuationBear

// Calculate BOS strength (A6)
bosBodySize = math.abs(close - open)
bosIsStrong = bosBodySize > (atrValue * strongBOSThreshold)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal Structure Filter (A5) - V7.0 REWRITE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SYMMETRIC CONTAINER-BASED TEST: Any break inside [impulseLow, impulseHigh] is internal
// This applies to BOTH bullish and bearish breaks regardless of current structure state
isInsideImpulseRange = false
if useInternalFilter and not na(impulseHigh) and not na(impulseLow)
    // Simple symmetric test: if the breaking price (close) is inside the impulse container,
    // this is an internal break and should NOT flip structure or emit a BOS label
    breakPrice = close
    if breakPrice > impulseLow and breakPrice < impulseHigh
        isInsideImpulseRange := true

// Internal break detection (for labeling)
internalBullBreak = rawBullishBOS and isInsideImpulseRange
internalBearBreak = rawBearishBOS and isInsideImpulseRange

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Protected Level Check (A4) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Structure invalidation via protected levels
protectedLevelBroken = false
if useProtectedLevels
    if structureState == 1 and not na(protectedLow) and close < protectedLow
        protectedLevelBroken := true
    if structureState == -1 and not na(protectedHigh) and close > protectedHigh
        protectedLevelBroken := true

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Final BOS Determination - V7.0 REWRITE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// V7.0: BOS valid when:
// - INITIAL STATE (neutral): Any raw BOS establishes direction
// - SAME-BIAS CONTINUATIONS: Always valid if raw break detected (extends impulse)
// - OPPOSITE-BIAS REVERSALS: Protected level break IS the BOS (no swing crossover needed)

// Determine break context
isNeutral = structureState == 0  // Initial/no established structure yet
isBullContinuation = rawBullishBOS and structureState == 1   // Bullish BOS while already bullish
isBearContinuation = rawBearishBOS and structureState == -1  // Bearish BOS while already bearish

// V7.0 FIX: For REVERSALS, breaking the protected level IS the structure flip
// Per SMC: Protected level break = structure invalidation = BOS
// We check for FIRST break of protected level (crossover, not just being above/below)
protectedHighBroken = structureState == -1 and not na(protectedHigh) and close > protectedHigh and close[1] <= protectedHigh
protectedLowBroken = structureState == 1 and not na(protectedLow) and close < protectedLow and close[1] >= protectedLow

// Apply rules:
// - Initial state: Any raw BOS is valid (establishes structure)
// - Continuations: Always valid (extend impulse)
// - Reversals: Protected level break triggers BOS (or rawBOS + protectedBroken for internal breaks that also break protected)
bullishBOS = (isNeutral and rawBullishBOS) or isBullContinuation or protectedHighBroken
bearishBOS = (isNeutral and rawBearishBOS) or isBearContinuation or protectedLowBroken

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Structure State Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Track previous state
prevStructureState := structureState

// Pre-calculate lookback values for protected levels (must be called on every bar for consistency)
lookbackBars = swingLength * protectedLookback
lowestLookback = ta.lowest(low, lookbackBars)
highestLookback = ta.highest(high, lookbackBars)

// Track consolidation state (declared here so it's available in BOS blocks)
var bool wasConsolidating = false
var int consolidationStartBar = na

// Update structure on valid BOS
if bullishBOS
    structureState := 1
    lastBOSStrong := bosIsStrong
    barsSinceImpulse := 0
    wasConsolidating := false
    
    // V7.0 SMC-CORRECT: Protected level = the most recent swing low (HL) at the moment BOS triggers
    // Per ICT/SMC research: "The swing low prior to BOS" is the protected low
    // Using confirmedSwingLow ensures it's the HL that DIRECTLY preceded/enabled this BOS
    // This also ensures protected low TRAILS UP with each continuation BOS
    protectedLow := not na(confirmedSwingLow) ? confirmedSwingLow : lowestLookback
    protectedLowBar := not na(confirmedLowBar) ? confirmedLowBar : bar_index
    
    // Impulse range: origin = protected low, high = highest since that swing
    impulseLow := protectedLow
    
    // Find impulse high: highest since the protected low bar
    barsFromSwing = bar_index - protectedLowBar
    safeBarsFromSwing = math.max(1, math.min(barsFromSwing + 1, bar_index + 1))
    impulseHigh := ta.highest(high, safeBarsFromSwing)
    lastImpulseBar := bar_index
    
    // Mark consolidation as broken (keep historical if enabled)
    if not na(consolidationBox)
        if showHistoricalConsolidation
            // Finalize the box (stop extending, change color)
            box.set_right(consolidationBox, bar_index)
            box.set_bgcolor(consolidationBox, brokenConsolidationColor)
            box.set_border_color(consolidationBox, color.rgb(80, 80, 80))
            
            // Add to historical array
            array.push(historicalConsolidationBoxes, consolidationBox)
            
            // Limit historical boxes
            if array.size(historicalConsolidationBoxes) > maxHistoricalBoxes
                oldBox = array.shift(historicalConsolidationBoxes)
                box.delete(oldBox)
        else
            box.delete(consolidationBox)
        consolidationBox := na

if bearishBOS
    structureState := -1
    lastBOSStrong := bosIsStrong
    barsSinceImpulse := 0
    wasConsolidating := false
    
    // V7.0 SMC-CORRECT: Protected level = the most recent swing high (LH) at the moment BOS triggers
    // Per ICT/SMC research: "The swing high prior to BOS" is the protected high
    // Using confirmedSwingHigh ensures it's the LH that DIRECTLY preceded/enabled this BOS
    // This also ensures protected high TRAILS DOWN with each continuation BOS
    protectedHigh := not na(confirmedSwingHigh) ? confirmedSwingHigh : highestLookback
    protectedHighBar := not na(confirmedHighBar) ? confirmedHighBar : bar_index
    
    // Impulse range: origin = protected high, low = lowest since that swing
    impulseHigh := protectedHigh
    
    // Find impulse low: lowest since the protected high bar
    barsFromSwing = bar_index - protectedHighBar
    safeBarsFromSwing = math.max(1, math.min(barsFromSwing + 1, bar_index + 1))
    impulseLow := ta.lowest(low, safeBarsFromSwing)
    lastImpulseBar := bar_index
    
    // Mark consolidation as broken (keep historical if enabled)
    if not na(consolidationBox)
        if showHistoricalConsolidation
            // Finalize the box (stop extending, change color)
            box.set_right(consolidationBox, bar_index)
            box.set_bgcolor(consolidationBox, brokenConsolidationColor)
            box.set_border_color(consolidationBox, color.rgb(80, 80, 80))
            
            // Add to historical array
            array.push(historicalConsolidationBoxes, consolidationBox)
            
            // Limit historical boxes
            if array.size(historicalConsolidationBoxes) > maxHistoricalBoxes
                oldBox = array.shift(historicalConsolidationBoxes)
                box.delete(oldBox)
        else
            box.delete(consolidationBox)
        consolidationBox := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Consolidation Detection (A1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Post-BOS Range Logic: True consolidation = range between broken level and next swing
// TEMPORARILY DISABLED - Will revisit consolidation logic later

// CONSOLIDATION DETECTION TEMPORARILY DISABLED
// Will revisit this logic later - for now focusing on core indicator functionality
//
// if useConsolidation
//     // POST-BOS CONSOLIDATION DETECTION  
//     // After BOS: Range = Broken High/Low to Next Swing Low/High
//     // [All consolidation logic commented out]
//

// Increment bars since last BOS (unless currently in BOS)
if not bullishBOS and not bearishBOS
    barsSinceImpulse += 1

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Dynamic Impulse Container Updates - V7.0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// On EVERY bar, extend the impulse container in the direction of the current trend
// This ensures the internal filter always has accurate bounds for break classification
if structureState == 1 and not na(impulseHigh)
    // Bullish: Extend impulse high as price makes new highs
    impulseHigh := math.max(impulseHigh, high)
    // Note: impulseLow (protected low) stays fixed until structure flips

if structureState == -1 and not na(impulseLow)
    // Bearish: Extend impulse low as price makes new lows
    impulseLow := math.min(impulseLow, low)
    // Note: impulseHigh (protected high) stays fixed until structure flips

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Protected Level Trailing - V7.0 SMC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Per SMC: Protected levels should TRAIL with structure-confirming swings
// When a new swing confirms existing structure, update the protected level
// This ensures reversal detection uses the correct, current level

// Bullish structure: Trail protected low UP when new Higher Low is confirmed
if structureState == 1 and not na(swingLow)
    // New swing low detected - check if it's a Higher Low (confirms bullish structure)
    if swingLow > protectedLow
        protectedLow := swingLow
        protectedLowBar := bar_index - swingLength
        impulseLow := swingLow  // Also update impulse origin

// Bearish structure: Trail protected high DOWN when new Lower High is confirmed
if structureState == -1 and not na(swingHigh)
    // New swing high detected - check if it's a Lower High (confirms bearish structure)
    if swingHigh < protectedHigh
        protectedHigh := swingHigh
        protectedHighBar := bar_index - swingLength
        impulseHigh := swingHigh  // Also update impulse origin

// Liquidity Sweep detection
bullSweep = showLiqSweeps and not na(confirmedSwingHigh) and high > confirmedSwingHigh and close <= confirmedSwingHigh
bearSweep = showLiqSweeps and not na(confirmedSwingLow) and low < confirmedSwingLow and close >= confirmedSwingLow

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ VISUALIZATION â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Protected Level Lines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var line protectedLowLine = na
var line protectedHighLine = na
var label protectedLowLabel = na
var label protectedHighLabel = na

if showProtectedLines and useProtectedLevels
    lineStyle = getLineStyle(protectedLineStyle)
    
    // Update/create protected low line (bullish structure)
    if structureState == 1 and not na(protectedLow)
        // Use a reasonable start bar - either the protectedLowBar or a recent lookback if too old
        lineStartBar = not na(protectedLowBar) ? math.max(protectedLowBar, bar_index - 200) : bar_index - 50
        
        if na(protectedLowLine)
            protectedLowLine := line.new(lineStartBar, protectedLow, bar_index + 5, protectedLow,
                                         color=bullColor, width=2, style=lineStyle)
            protectedLowLabel := label.new(bar_index + 5, protectedLow, "Protected Low",
                                           style=label.style_label_left,
                                           color=color.new(bullColor, 80),
                                           textcolor=bullColor,
                                           size=size.tiny)
        else
            line.set_x1(protectedLowLine, lineStartBar)
            line.set_x2(protectedLowLine, bar_index + 5)
            line.set_y1(protectedLowLine, protectedLow)
            line.set_y2(protectedLowLine, protectedLow)
            label.set_x(protectedLowLabel, bar_index + 5)
            label.set_y(protectedLowLabel, protectedLow)
    else
        if not na(protectedLowLine)
            line.delete(protectedLowLine)
            label.delete(protectedLowLabel)
            protectedLowLine := na
            protectedLowLabel := na
    
    // Update/create protected high line (bearish structure)
    if structureState == -1 and not na(protectedHigh)
        // Use a reasonable start bar - either the protectedHighBar or a recent lookback if too old
        lineStartBarHigh = not na(protectedHighBar) ? math.max(protectedHighBar, bar_index - 200) : bar_index - 50
        
        if na(protectedHighLine)
            protectedHighLine := line.new(lineStartBarHigh, protectedHigh, bar_index + 5, protectedHigh,
                                          color=bearColor, width=2, style=lineStyle)
            protectedHighLabel := label.new(bar_index + 5, protectedHigh, "Protected High",
                                            style=label.style_label_left,
                                            color=color.new(bearColor, 80),
                                            textcolor=bearColor,
                                            size=size.tiny)
        else
            line.set_x1(protectedHighLine, lineStartBarHigh)
            line.set_x2(protectedHighLine, bar_index + 5)
            line.set_y1(protectedHighLine, protectedHigh)
            line.set_y2(protectedHighLine, protectedHigh)
            label.set_x(protectedHighLabel, bar_index + 5)
            label.set_y(protectedHighLabel, protectedHigh)
    else
        if not na(protectedHighLine)
            line.delete(protectedHighLine)
            label.delete(protectedHighLabel)
            protectedHighLine := na
            protectedHighLabel := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Swing High/Low Labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if showLabels and not na(swingHigh)
    isHigherHigh = not na(prevSwingHigh) and swingHigh > prevSwingHigh
    isLowerHigh = not na(prevSwingHigh) and swingHigh < prevSwingHigh
    labelColor = isHigherHigh ? bullColor : (isLowerHigh ? bearColor : neutralColor)
    
    if isHigherHigh
        labelText = "HH\n" + str.tostring(swingHigh, format.mintick)
        label.new(bar_index - swingLength, swingHigh, labelText, 
                  style=label.style_label_down, 
                  color=color.new(labelColor, 80), 
                  textcolor=color.white, 
                  size=size.small)
    else
        labelText = isLowerHigh ? "LH" : "H"
        label.new(bar_index - swingLength, swingHigh, labelText, 
                  style=label.style_label_down, 
                  color=color.new(labelColor, 80), 
                  textcolor=labelColor, 
                  size=size.small)

if showLabels and not na(swingLow)
    isHigherLow = not na(prevSwingLow) and swingLow > prevSwingLow
    isLowerLow = not na(prevSwingLow) and swingLow < prevSwingLow
    labelColor = isHigherLow ? bullColor : (isLowerLow ? bearColor : neutralColor)
    
    if isLowerLow
        labelText = "LL\n" + str.tostring(swingLow, format.mintick)
        label.new(bar_index - swingLength, swingLow, labelText, 
                  style=label.style_label_up, 
                  color=color.new(labelColor, 80), 
                  textcolor=color.white, 
                  size=size.small)
    else
        labelText = isHigherLow ? "HL" : "L"
        label.new(bar_index - swingLength, swingLow, labelText, 
                  style=label.style_label_up, 
                  color=color.new(labelColor, 80), 
                  textcolor=labelColor, 
                  size=size.small)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal Structure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if showInternalStructure and not na(internalHigh)
    label.new(bar_index - internalLength, internalHigh, "iH", 
              style=label.style_label_down, 
              color=color.new(internalColor, 70), 
              textcolor=internalColor, 
              size=size.tiny)
    line.new(bar_index - internalLength, internalHigh, bar_index + 5, internalHigh, 
             color=color.new(internalColor, 50), 
             width=1, 
             style=line.style_dotted)

if showInternalStructure and not na(internalLow)
    label.new(bar_index - internalLength, internalLow, "iL", 
              style=label.style_label_up, 
              color=color.new(internalColor, 70), 
              textcolor=internalColor, 
              size=size.tiny)
    line.new(bar_index - internalLength, internalLow, bar_index + 5, internalLow, 
             color=color.new(internalColor, 50), 
             width=1, 
             style=line.style_dotted)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal Break Labels (A5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if showInternalBreaks and internalBullBreak
    // Draw dotted line at the internal break level
    if not na(confirmedHighBar)
        line.new(confirmedHighBar, confirmedSwingHigh, bar_index + 10, confirmedSwingHigh, 
                 color=color.new(bullColor, 50), 
                 width=1, 
                 style=line.style_dotted)
    
    label.new(bar_index, high, "iBOSâ†‘", 
              style=label.style_label_down, 
              color=color.new(bullColor, 70), 
              textcolor=bullColor, 
              size=size.tiny)

if showInternalBreaks and internalBearBreak
    // Draw dotted line at the internal break level
    if not na(confirmedLowBar)
        line.new(confirmedLowBar, confirmedSwingLow, bar_index + 10, confirmedSwingLow, 
                 color=color.new(bearColor, 50), 
                 width=1, 
                 style=line.style_dotted)
    
    label.new(bar_index, low, "iBOSâ†“", 
              style=label.style_label_up, 
              color=color.new(bearColor, 70), 
              textcolor=bearColor, 
              size=size.tiny)

// Trap warnings
if showTrapWarnings and internalBullBreak
    label.new(bar_index, high + atrValue * 0.2, "âš ï¸ TRAP?", 
              style=label.style_label_down, 
              color=color.new(color.orange, 50), 
              textcolor=color.orange, 
              size=size.tiny)

if showTrapWarnings and internalBearBreak
    label.new(bar_index, low - atrValue * 0.2, "âš ï¸ TRAP?", 
              style=label.style_label_up, 
              color=color.new(color.orange, 50), 
              textcolor=color.orange, 
              size=size.tiny)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Zig-Zag Path (Array-Based) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var array<float> zzPrices = array.new<float>()
var array<int> zzBars = array.new<int>()
var array<bool> zzIsHigh = array.new<bool>()

if showZigZag
    // Process swing HIGH
    if not na(swingHigh)
        currentHighBar = bar_index - swingLength
        currentHighPrice = swingHigh
        
        if array.size(zzIsHigh) > 0 and array.get(zzIsHigh, array.size(zzIsHigh) - 1) == true
            lastPrice = array.get(zzPrices, array.size(zzPrices) - 1)
            if currentHighPrice > lastPrice
                array.set(zzPrices, array.size(zzPrices) - 1, currentHighPrice)
                array.set(zzBars, array.size(zzBars) - 1, currentHighBar)
                
                if array.size(zigZagLines) > 0
                    lastLine = array.pop(zigZagLines)
                    line.delete(lastLine)
                    
                    if array.size(zzPrices) >= 2
                        prevPrice = array.get(zzPrices, array.size(zzPrices) - 2)
                        prevBar = array.get(zzBars, array.size(zzBars) - 2)
                        zigColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
                        newLine = line.new(prevBar, prevPrice, currentHighBar, currentHighPrice, 
                                 color=zigColor, width=2, style=line.style_solid)
                        array.push(zigZagLines, newLine)
        else
            array.push(zzPrices, currentHighPrice)
            array.push(zzBars, currentHighBar)
            array.push(zzIsHigh, true)
            
            if array.size(zzPrices) >= 2
                prevPrice = array.get(zzPrices, array.size(zzPrices) - 2)
                prevBar = array.get(zzBars, array.size(zzBars) - 2)
                zigColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
                newLine = line.new(prevBar, prevPrice, currentHighBar, currentHighPrice, 
                         color=zigColor, width=2, style=line.style_solid)
                array.push(zigZagLines, newLine)
                
                if array.size(zigZagLines) > maxZigZagLines
                    oldLine = array.shift(zigZagLines)
                    line.delete(oldLine)
            
            if array.size(zzPrices) > maxZigZagLines + 1
                array.shift(zzPrices)
                array.shift(zzBars)
                array.shift(zzIsHigh)
    
    // Process swing LOW
    if not na(swingLow)
        currentLowBar = bar_index - swingLength
        currentLowPrice = swingLow
        
        if array.size(zzIsHigh) > 0 and array.get(zzIsHigh, array.size(zzIsHigh) - 1) == false
            lastPrice = array.get(zzPrices, array.size(zzPrices) - 1)
            if currentLowPrice < lastPrice
                array.set(zzPrices, array.size(zzPrices) - 1, currentLowPrice)
                array.set(zzBars, array.size(zzBars) - 1, currentLowBar)
                
                if array.size(zigZagLines) > 0
                    lastLine = array.pop(zigZagLines)
                    line.delete(lastLine)
                    
                    if array.size(zzPrices) >= 2
                        prevPrice = array.get(zzPrices, array.size(zzPrices) - 2)
                        prevBar = array.get(zzBars, array.size(zzBars) - 2)
                        zigColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
                        newLine = line.new(prevBar, prevPrice, currentLowBar, currentLowPrice, 
                                 color=zigColor, width=2, style=line.style_solid)
                        array.push(zigZagLines, newLine)
        else
            array.push(zzPrices, currentLowPrice)
            array.push(zzBars, currentLowBar)
            array.push(zzIsHigh, false)
            
            if array.size(zzPrices) >= 2
                prevPrice = array.get(zzPrices, array.size(zzPrices) - 2)
                prevBar = array.get(zzBars, array.size(zzBars) - 2)
                zigColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
                newLine = line.new(prevBar, prevPrice, currentLowBar, currentLowPrice, 
                         color=zigColor, width=2, style=line.style_solid)
                array.push(zigZagLines, newLine)
                
                if array.size(zigZagLines) > maxZigZagLines
                    oldLine = array.shift(zigZagLines)
                    line.delete(oldLine)
            
            if array.size(zzPrices) > maxZigZagLines + 1
                array.shift(zzPrices)
                array.shift(zzBars)
                array.shift(zzIsHigh)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Developing Swing Level Lines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These show the active levels that need to break for BOS - visible BEFORE confirmation
var line developingHighLine = na
var line developingLowLine = na
var label developingHighLabel = na
var label developingLowLabel = na

if showDevelopingLevels
    // Update developing high line (level to break for bullish BOS)
    if not na(confirmedSwingHigh) and not na(confirmedHighBar)
        // Delete old line and recreate (to extend it)
        if not na(developingHighLine)
            line.delete(developingHighLine)
        if not na(developingHighLabel)
            label.delete(developingHighLabel)
        
        // Only show if not already broken
        if close <= confirmedSwingHigh
            developingHighLine := line.new(confirmedHighBar, confirmedSwingHigh, bar_index + 10, confirmedSwingHigh,
                                           color=color.new(bearColor, 50), width=1, style=line.style_dashed)
            developingHighLabel := label.new(bar_index + 10, confirmedSwingHigh, "SH", 
                                             style=label.style_label_left,
                                             color=color.new(bearColor, 85),
                                             textcolor=bearColor,
                                             size=size.tiny)
    
    // Update developing low line (level to break for bearish BOS)
    if not na(confirmedSwingLow) and not na(confirmedLowBar)
        // Delete old line and recreate (to extend it)
        if not na(developingLowLine)
            line.delete(developingLowLine)
        if not na(developingLowLabel)
            label.delete(developingLowLabel)
        
        // Only show if not already broken
        if close >= confirmedSwingLow
            developingLowLine := line.new(confirmedLowBar, confirmedSwingLow, bar_index + 10, confirmedSwingLow,
                                          color=color.new(bullColor, 50), width=1, style=line.style_dashed)
            developingLowLabel := label.new(bar_index + 10, confirmedSwingLow, "SL",
                                            style=label.style_label_left,
                                            color=color.new(bullColor, 85),
                                            textcolor=bullColor,
                                            size=size.tiny)
else
    // Clean up lines when setting is disabled
    if not na(developingHighLine)
        line.delete(developingHighLine)
        developingHighLine := na
    if not na(developingHighLabel)
        label.delete(developingHighLabel)
        developingHighLabel := na
    if not na(developingLowLine)
        line.delete(developingLowLine)
        developingLowLine := na
    if not na(developingLowLabel)
        label.delete(developingLowLabel)
        developingLowLabel := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BOS Lines with Strength Grading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// When BOS confirms, draw the solid confirmation line and label
if bullishBOS and not na(confirmedHighBar)
    // Remove the developing line since it's now confirmed
    if not na(developingHighLine)
        line.delete(developingHighLine)
        developingHighLine := na
    if not na(developingHighLabel)
        label.delete(developingHighLabel)
        developingHighLabel := na
    
    // Determine color based on strength - bullish uses green tones
    bosColor = bullColor
    if useDisplacementGrading
        bosColor := bosIsStrong ? color.rgb(0, 255, 100) : color.rgb(0, 180, 80)  // Bright green / dimmer green
    else
        bosColor := bullColor
    
    strengthSuffix = ""
    if useDisplacementGrading and showStrengthLabels
        strengthSuffix := bosIsStrong ? " (S)" : " (W)"
    
    line.new(confirmedHighBar, confirmedSwingHigh, bar_index, confirmedSwingHigh, 
             color=bosColor, width=2, style=line.style_solid)
    label.new(bar_index, confirmedSwingHigh, "BOS â†‘" + strengthSuffix, 
              style=label.style_label_down, 
              color=color.new(bosColor, 80), 
              textcolor=bosColor, 
              size=size.small)

if bearishBOS and not na(confirmedLowBar)
    // Remove the developing line since it's now confirmed
    if not na(developingLowLine)
        line.delete(developingLowLine)
        developingLowLine := na
    if not na(developingLowLabel)
        label.delete(developingLowLabel)
        developingLowLabel := na
    
    // Determine color based on strength - bearish uses red tones
    bosColor = bearColor
    if useDisplacementGrading
        bosColor := bosIsStrong ? color.rgb(255, 50, 50) : color.rgb(200, 80, 80)  // Bright red / dimmer red
    else
        bosColor := bearColor
    
    strengthSuffix = ""
    if useDisplacementGrading and showStrengthLabels
        strengthSuffix := bosIsStrong ? " (S)" : " (W)"
    
    line.new(confirmedLowBar, confirmedSwingLow, bar_index, confirmedSwingLow, 
             color=bosColor, width=2, style=line.style_solid)
    label.new(bar_index, confirmedSwingLow, "BOS â†“" + strengthSuffix, 
              style=label.style_label_up, 
              color=color.new(bosColor, 80), 
              textcolor=bosColor, 
              size=size.small)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Liquidity Sweeps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if bullSweep and not na(confirmedHighBar)
    line.new(confirmedHighBar, confirmedSwingHigh, bar_index, confirmedSwingHigh, 
             color=bearColor, width=1, style=line.style_dotted)
    label.new(bar_index, high, "Sweep", 
              style=label.style_xcross, 
              color=color.new(bearColor, 80), 
              textcolor=bearColor, 
              size=size.tiny)

if bearSweep and not na(confirmedLowBar)
    line.new(confirmedLowBar, confirmedSwingLow, bar_index, confirmedSwingLow, 
             color=bullColor, width=1, style=line.style_dotted)
    label.new(bar_index, low, "Sweep", 
              style=label.style_xcross, 
              color=color.new(bullColor, 80), 
              textcolor=bullColor, 
              size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ SUPPLY/DEMAND ZONES (A7) â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Zone colors
demandZoneColor = color.new(bullColor, 85)
supplyZoneColor = color.new(bearColor, 85)

// Create Demand Zone on Bullish BOS at the SWING LOW that preceded the move
createDemandZone = showZones and bullishBOS and not na(confirmedSwingLow) and not na(confirmedLowBar)
if zoneDirectionFilter
    createDemandZone := createDemandZone and structureState == 1

if createDemandZone
    hasFVG = detectBullishFVG(5)
    
    if hasFVG or not requireFVG
        // Use confirmed swing low as the zone level (the actual pivot)
        zoneTop = confirmedSwingLow + atrValue * 0.1
        zoneBottom = confirmedSwingLow - atrValue * 0.4
        
        // Check if a demand zone already exists at this level (within 0.5 ATR)
        zoneExists = false
        if array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                existingZone = array.get(activeZones, i)
                if not existingZone.isSupply
                    // Check if zones overlap
                    if math.abs(existingZone.top - zoneTop) < atrValue * 0.5
                        zoneExists := true
                        break
        
        if not zoneExists
            zoneBox = box.new(confirmedLowBar, zoneTop, bar_index + zoneExtendBars, zoneBottom,
                              bgcolor=demandZoneColor, 
                              border_color=bullColor,
                              border_width=1)
            
            zoneLbl = label.new(confirmedLowBar, zoneBottom, "DEMAND", 
                               style=label.style_label_up,
                               color=color.new(bullColor, 90),
                               textcolor=bullColor,
                               size=size.tiny)
            
            newZone = Zone.new(zoneBox, zoneLbl, zoneTop, zoneBottom, confirmedLowBar, false, false, false, hasFVG)
            array.push(activeZones, newZone)
            
            if array.size(activeZones) > maxZones
                oldZone = array.shift(activeZones)
                box.delete(oldZone.zoneBox)
                label.delete(oldZone.zoneLabel)

// V7.0: Optional Internal Demand Zone (at internal bullish breaks)
// Internal zones IGNORE direction filter - they're reference zones, so show in both BULL and BEAR
createInternalDemandZone = showZones and showInternalZones and internalBullBreak and not na(confirmedSwingLow) and not na(confirmedLowBar)

if createInternalDemandZone
    hasFVG = detectBullishFVG(5)
    
    if hasFVG or not requireFVG
        zoneTop = confirmedSwingLow + atrValue * 0.1
        zoneBottom = confirmedSwingLow - atrValue * 0.4
        
        zoneExists = false
        if array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                existingZone = array.get(activeZones, i)
                if not existingZone.isSupply
                    if math.abs(existingZone.top - zoneTop) < atrValue * 0.5
                        zoneExists := true
                        break
        
        if not zoneExists
            // Internal zones are DIMMER (95 transparency vs 85)
            internalDemandColor = color.new(bullColor, 95)
            zoneBox = box.new(confirmedLowBar, zoneTop, bar_index + zoneExtendBars, zoneBottom,
                              bgcolor=internalDemandColor, 
                              border_color=color.new(bullColor, 70),
                              border_width=1,
                              border_style=line.style_dotted)  // Dotted border
            
            zoneLbl = label.new(confirmedLowBar, zoneBottom, "iDEMAND",  // Different label
                               style=label.style_label_up,
                               color=color.new(bullColor, 95),
                               textcolor=color.new(bullColor, 30),
                               size=size.tiny)
            
            newZone = Zone.new(zoneBox, zoneLbl, zoneTop, zoneBottom, confirmedLowBar, false, false, false, hasFVG)
            array.push(activeZones, newZone)
            
            if array.size(activeZones) > maxZones
                oldZone = array.shift(activeZones)
                box.delete(oldZone.zoneBox)
                label.delete(oldZone.zoneLabel)

// Create Supply Zone on Bearish BOS at the SWING HIGH that preceded the move
createSupplyZone = showZones and bearishBOS and not na(confirmedSwingHigh) and not na(confirmedHighBar)
if zoneDirectionFilter
    createSupplyZone := createSupplyZone and structureState == -1

if createSupplyZone
    hasFVG = detectBearishFVG(5)
    
    if hasFVG or not requireFVG
        // Use confirmed swing high as the zone level (the actual pivot)
        zoneBottom = confirmedSwingHigh - atrValue * 0.1
        zoneTop = confirmedSwingHigh + atrValue * 0.4
        
        // Check if a supply zone already exists at this level (within 0.5 ATR)
        zoneExists = false
        if array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                existingZone = array.get(activeZones, i)
                if existingZone.isSupply
                    // Check if zones overlap
                    if math.abs(existingZone.bottom - zoneBottom) < atrValue * 0.5
                        zoneExists := true
                        break
        
        if not zoneExists
            zoneBox = box.new(confirmedHighBar, zoneTop, bar_index + zoneExtendBars, zoneBottom,
                              bgcolor=supplyZoneColor, 
                              border_color=bearColor,
                              border_width=1)
            
            zoneLbl = label.new(confirmedHighBar, zoneTop, "SUPPLY", 
                               style=label.style_label_down,
                               color=color.new(bearColor, 90),
                               textcolor=bearColor,
                               size=size.tiny)
            
            newZone = Zone.new(zoneBox, zoneLbl, zoneTop, zoneBottom, confirmedHighBar, true, false, false, hasFVG)
            array.push(activeZones, newZone)
            
            if array.size(activeZones) > maxZones
                oldZone = array.shift(activeZones)
                box.delete(oldZone.zoneBox)
                label.delete(oldZone.zoneLabel)

// V7.0: Optional Internal Supply Zone (at internal bearish breaks)
// Internal zones IGNORE direction filter - they're reference zones, so show in both BULL and BEAR
createInternalSupplyZone = showZones and showInternalZones and internalBearBreak and not na(confirmedSwingHigh) and not na(confirmedHighBar)

if createInternalSupplyZone
    hasFVG = detectBearishFVG(5)
    
    if hasFVG or not requireFVG
        zoneBottom = confirmedSwingHigh - atrValue * 0.1
        zoneTop = confirmedSwingHigh + atrValue * 0.4
        
        zoneExists = false
        if array.size(activeZones) > 0
            for i = 0 to array.size(activeZones) - 1
                existingZone = array.get(activeZones, i)
                if existingZone.isSupply
                    if math.abs(existingZone.bottom - zoneBottom) < atrValue * 0.5
                        zoneExists := true
                        break
        
        if not zoneExists
            // Internal zones are DIMMER (95 transparency vs 85)
            internalSupplyColor = color.new(bearColor, 95)
            zoneBox = box.new(confirmedHighBar, zoneTop, bar_index + zoneExtendBars, zoneBottom,
                              bgcolor=internalSupplyColor, 
                              border_color=color.new(bearColor, 70),
                              border_width=1,
                              border_style=line.style_dotted)  // Dotted border
            
            zoneLbl = label.new(confirmedHighBar, zoneTop, "iSUPPLY",  // Different label
                               style=label.style_label_down,
                               color=color.new(bearColor, 95),
                               textcolor=color.new(bearColor, 30),
                               size=size.tiny)
            
            newZone = Zone.new(zoneBox, zoneLbl, zoneTop, zoneBottom, confirmedHighBar, true, false, false, hasFVG)
            array.push(activeZones, newZone)
            
            if array.size(activeZones) > maxZones
                oldZone = array.shift(activeZones)
                box.delete(oldZone.zoneBox)
                label.delete(oldZone.zoneLabel)

// Update zone status
if array.size(activeZones) > 0
    for i = array.size(activeZones) - 1 to 0
        zone = array.get(activeZones, i)
        
        // Check if zone is touched
        if not zone.tested
            if (zone.isSupply and high >= zone.bottom) or (not zone.isSupply and low <= zone.top)
                zone.tested := true
                box.set_bgcolor(zone.zoneBox, color.new(color.yellow, 85))
        
        // Check if zone is invalidated
        if not zone.invalidated
            if (zone.isSupply and close > zone.top) or (not zone.isSupply and close < zone.bottom)
                zone.invalidated := true
                if removeMitigated
                    box.delete(zone.zoneBox)
                    label.delete(zone.zoneLabel)
                    array.remove(activeZones, i)
                else
                    box.set_bgcolor(zone.zoneBox, color.new(color.gray, 90))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ PULLBACK ENTRY (FIB GOLDEN ZONE) â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track swing points for fib calculation
var float bosSwingLow = na      // Origin for bullish fib (0%)
var float bosSwingHigh = na     // Extreme for bullish fib (100%)
var int bosSwingLowBar = na
var int bosSwingHighBar = na

// Pullback zone visualization objects
var box goldenZoneBox = na
var box deepZoneBox = na
var line fib0Line = na
var line fib50Line = na
var line fib618Line = na
var line fib786Line = na
var line fib100Line = na
var label fib0Label = na
var label fib50Label = na
var label fib618Label = na
var label fib786Label = na
var label fib100Label = na

// Pullback zone state
var float currentFibOrigin = na
var float currentFibExtreme = na
var float currentFib50 = na
var float currentFib618 = na
var float currentFib786 = na
var int pullbackDirection = 0    // 1 = bullish, -1 = bearish
var bool inGoldenZone = false
var bool inDeepZone = false
var bool pullbackConfirmed = false
var int pullbackStartBar = na

// Internal structure tracking for confirmation
var float internalSwingHigh = na
var float internalSwingLow = na

// Detect internal structure for confirmation
miniSwingHigh = ta.pivothigh(high, internalLength, internalLength)
miniSwingLow = ta.pivotlow(low, internalLength, internalLength)

if not na(miniSwingHigh)
    internalSwingHigh := miniSwingHigh
if not na(miniSwingLow)
    internalSwingLow := miniSwingLow

// Function to clean up pullback zone visuals
cleanupPullbackZone() =>
    if not na(goldenZoneBox)
        box.delete(goldenZoneBox)
    if not na(deepZoneBox)
        box.delete(deepZoneBox)
    if not na(fib0Line)
        line.delete(fib0Line)
    if not na(fib50Line)
        line.delete(fib50Line)
    if not na(fib618Line)
        line.delete(fib618Line)
    if not na(fib786Line)
        line.delete(fib786Line)
    if not na(fib100Line)
        line.delete(fib100Line)
    if not na(fib0Label)
        label.delete(fib0Label)
    if not na(fib50Label)
        label.delete(fib50Label)
    if not na(fib618Label)
        label.delete(fib618Label)
    if not na(fib786Label)
        label.delete(fib786Label)
    if not na(fib100Label)
        label.delete(fib100Label)
    true

// Create new pullback zone on BOS
if showPullbackZone
    // Bullish BOS - set up for bullish pullback entry
    if bullishBOS and not na(impulseLow) and not na(impulseHigh)
        // Clean up old zone
        cleanupPullbackZone()

        // V7.0: Fib anchors use ACTIVE IMPULSE RANGE (not old swing points)
        // This ensures fibs draw from the current leg, preventing old-structure anchoring
        // Spec: Fib Low (0%) = impulse origin, Fib High (100%) = impulse extreme
        currentFibOrigin := impulseLow       // Origin of the bullish impulse
        currentFibExtreme := impulseHigh     // Current impulse extreme (updates dynamically)

        pullbackDirection := 1
        pullbackStartBar := bar_index
        pullbackConfirmed := false
        inGoldenZone := false
        inDeepZone := false

        // Calculate fib levels (for bullish: retracement goes DOWN from impulse high to impulse low)
        fibRange = currentFibExtreme - currentFibOrigin
        currentFib50 := currentFibExtreme - (fibRange * fibUpperLevel)
        currentFib618 := currentFibExtreme - (fibRange * fibLowerLevel)
        currentFib786 := currentFibExtreme - (fibRange * fibDeepLevel)

        // Reset internal swing for confirmation tracking
        internalSwingHigh := na
    
    // Bearish BOS - set up for bearish pullback entry
    if bearishBOS and not na(impulseHigh) and not na(impulseLow)
        // Clean up old zone
        cleanupPullbackZone()

        // V7.0: Fib anchors use ACTIVE IMPULSE RANGE (not old swing points)
        // Spec: Fib High (0%) = impulse origin, Fib Low (100%) = impulse extreme
        currentFibOrigin := impulseHigh      // Origin of the bearish impulse
        currentFibExtreme := impulseLow      // Current impulse extreme (updates dynamically)

        pullbackDirection := -1
        pullbackStartBar := bar_index
        pullbackConfirmed := false
        inGoldenZone := false
        inDeepZone := false

        // Calculate fib levels (for bearish: retracement goes UP from impulse low to impulse high)
        fibRange = currentFibOrigin - currentFibExtreme
        currentFib50 := currentFibExtreme + (fibRange * fibUpperLevel)
        currentFib618 := currentFibExtreme + (fibRange * fibLowerLevel)
        currentFib786 := currentFibExtreme + (fibRange * fibDeepLevel)

        // Reset internal swing for confirmation tracking
        internalSwingLow := na

// Update and draw pullback zone
if showPullbackZone and pullbackDirection != 0 and not na(currentFibOrigin)
    // Check if structure invalidated (protected level broken)
    zoneInvalidated = false
    if pullbackDirection == 1 and structureState != 1
        zoneInvalidated := true
    if pullbackDirection == -1 and structureState != -1
        zoneInvalidated := true

    // Note: Removed overly strict origin check - valid pullbacks can go to 0.786 or 1.0 fib
    // Zone persists as historical reference until replaced by new zone

    if zoneInvalidated
        // Don't cleanup - keep zone visible as historical reference
        // It will be replaced when next BOS creates a new zone
        pullbackDirection := 0
        currentFibOrigin := na
    else
        // V7.0: Dynamically sync fib extreme with impulse values
        // impulseHigh/Low update every bar as the impulse extends (per spec H1/H2)
        // The fib must track these updates to capture new extremes like the 80,600 low
        if pullbackDirection == 1
            currentFibExtreme := impulseHigh  // Sync with dynamic impulse high
            // Recalc fib levels
            fibRange = currentFibExtreme - currentFibOrigin
            if fibRange > 0
                currentFib50 := currentFibExtreme - (fibRange * fibUpperLevel)
                currentFib618 := currentFibExtreme - (fibRange * fibLowerLevel)
                currentFib786 := currentFibExtreme - (fibRange * fibDeepLevel)
        
        if pullbackDirection == -1
            currentFibExtreme := impulseLow  // Sync with dynamic impulse low
            // Recalc fib levels
            fibRange = currentFibOrigin - currentFibExtreme
            if fibRange > 0
                currentFib50 := currentFibExtreme + (fibRange * fibUpperLevel)
                currentFib618 := currentFibExtreme + (fibRange * fibLowerLevel)
                currentFib786 := currentFibExtreme + (fibRange * fibDeepLevel)

        // Check if price is in golden zone
        if pullbackDirection == 1
            inGoldenZone := low <= currentFib50 and close >= currentFib618
            inDeepZone := low <= currentFib618 and close >= currentFib786
        else
            inGoldenZone := high >= currentFib50 and close <= currentFib618
            inDeepZone := high >= currentFib618 and close <= currentFib786
        
        // Check for confirmation
        displacementConfirmed = false
        internalBOSConfirmed = false
        
        // Displacement candle check
        candleBody = math.abs(close - open)
        if pullbackDirection == 1
            displacementConfirmed := close > open and candleBody > (atrValue * displacementATR)
        else
            displacementConfirmed := close < open and candleBody > (atrValue * displacementATR)
        
        // Internal BOS check
        if pullbackDirection == 1 and not na(internalSwingHigh)
            internalBOSConfirmed := close > internalSwingHigh
        if pullbackDirection == -1 and not na(internalSwingLow)
            internalBOSConfirmed := close < internalSwingLow
        
        // Determine if confirmation triggered based on settings
        confirmationMet = false
        if confirmationType == "None"
            confirmationMet := inGoldenZone or inDeepZone
        else if confirmationType == "Displacement Candle"
            confirmationMet := (inGoldenZone or inDeepZone) and displacementConfirmed
        else if confirmationType == "Internal BOS"
            confirmationMet := (inGoldenZone or inDeepZone) and internalBOSConfirmed
        else if confirmationType == "Both"
            confirmationMet := (inGoldenZone or inDeepZone) and displacementConfirmed and internalBOSConfirmed
        
        // Draw/update visuals
        zoneRight = bar_index + 15
        fibLineRight = bar_index + 20
        
        // Clean up old drawings first
        if not na(goldenZoneBox)
            box.delete(goldenZoneBox)
        if not na(deepZoneBox)
            box.delete(deepZoneBox)
        if not na(fib0Line)
            line.delete(fib0Line)
        if not na(fib50Line)
            line.delete(fib50Line)
        if not na(fib618Line)
            line.delete(fib618Line)
        if not na(fib786Line)
            line.delete(fib786Line)
        if not na(fib100Line)
            line.delete(fib100Line)
        if not na(fib0Label)
            label.delete(fib0Label)
        if not na(fib50Label)
            label.delete(fib50Label)
        if not na(fib618Label)
            label.delete(fib618Label)
        if not na(fib786Label)
            label.delete(fib786Label)
        if not na(fib100Label)
            label.delete(fib100Label)
        
        // Determine zone colors based on direction and state
        var color currentGoldenColor = na
        var color borderColor = na
        
        if pullbackDirection == 1
            currentGoldenColor := goldenZoneColorBull
            borderColor := color.rgb(255, 215, 0)  // Gold border for bullish
            if inGoldenZone
                currentGoldenColor := color.new(color.yellow, 70)  // Highlight when price is in zone
        else
            currentGoldenColor := goldenZoneColorBear
            borderColor := color.rgb(255, 140, 0)  // Orange border for bearish
            if inGoldenZone
                currentGoldenColor := color.new(color.orange, 70)  // Highlight when price is in zone
        
        // Draw golden zone box
        if pullbackDirection == 1
            goldenZoneBox := box.new(pullbackStartBar, currentFib50, zoneRight, currentFib618,
                                     bgcolor=currentGoldenColor,
                                     border_color=borderColor,
                                     border_width=1)
        else
            goldenZoneBox := box.new(pullbackStartBar, currentFib618, zoneRight, currentFib50,
                                     bgcolor=currentGoldenColor,
                                     border_color=borderColor,
                                     border_width=1)
        
        // Draw deep zone if enabled
        if showDeepZone
            if pullbackDirection == 1
                deepZoneBox := box.new(pullbackStartBar, currentFib618, zoneRight, currentFib786,
                                       bgcolor=deepZoneColor,
                                       border_color=color.new(color.green, 60),
                                       border_width=1,
                                       border_style=line.style_dotted)
            else
                deepZoneBox := box.new(pullbackStartBar, currentFib786, zoneRight, currentFib618,
                                       bgcolor=deepZoneColor,
                                       border_color=color.new(color.red, 60),
                                       border_width=1,
                                       border_style=line.style_dotted)
        
        // Draw fib lines if enabled
        if showFibLines
            fibColor = pullbackDirection == 1 ? bullColor : bearColor
            
            fib0Line := line.new(pullbackStartBar, currentFibOrigin, fibLineRight, currentFibOrigin,
                                 color=color.new(fibColor, 60), width=1, style=line.style_dotted)
            fib50Line := line.new(pullbackStartBar, currentFib50, fibLineRight, currentFib50,
                                  color=color.new(color.yellow, 50), width=1, style=line.style_dashed)
            fib618Line := line.new(pullbackStartBar, currentFib618, fibLineRight, currentFib618,
                                   color=color.new(color.orange, 50), width=1, style=line.style_dashed)
            fib786Line := line.new(pullbackStartBar, currentFib786, fibLineRight, currentFib786,
                                   color=color.new(color.red, 60), width=1, style=line.style_dotted)
            fib100Line := line.new(pullbackStartBar, currentFibExtreme, fibLineRight, currentFibExtreme,
                                   color=color.new(fibColor, 60), width=1, style=line.style_dotted)
            
            // Labels
            fib0Label := label.new(fibLineRight, currentFibOrigin, "0%",
                                   style=label.style_label_left, color=color.new(fibColor, 90),
                                   textcolor=fibColor, size=size.tiny)
            fib50Label := label.new(fibLineRight, currentFib50, str.tostring(fibUpperLevel * 100, "#.#") + "%",
                                    style=label.style_label_left, color=color.new(color.yellow, 90),
                                    textcolor=color.yellow, size=size.tiny)
            fib618Label := label.new(fibLineRight, currentFib618, str.tostring(fibLowerLevel * 100, "#.#") + "%",
                                     style=label.style_label_left, color=color.new(color.orange, 90),
                                     textcolor=color.orange, size=size.tiny)
            fib786Label := label.new(fibLineRight, currentFib786, str.tostring(fibDeepLevel * 100, "#.#") + "%",
                                     style=label.style_label_left, color=color.new(color.red, 90),
                                     textcolor=color.red, size=size.tiny)
            fib100Label := label.new(fibLineRight, currentFibExtreme, "100%",
                                     style=label.style_label_left, color=color.new(fibColor, 90),
                                     textcolor=fibColor, size=size.tiny)
        
        // Show entry signal when confirmation triggers
        if showConfirmationSignal and confirmationMet and not pullbackConfirmed
            pullbackConfirmed := true
            signalColor = pullbackDirection == 1 ? bullColor : bearColor
            signalText = pullbackDirection == 1 ? "â–² ENTRY" : "â–¼ ENTRY"
            signalStyle = pullbackDirection == 1 ? label.style_label_up : label.style_label_down
            signalY = pullbackDirection == 1 ? low - atrValue * 0.3 : high + atrValue * 0.3
            
            label.new(bar_index, signalY, signalText,
                      style=signalStyle,
                      color=signalColor,
                      textcolor=color.white,
                      size=size.normal)

// Confirmation alert conditions
pullbackEntryLong = showPullbackZone and pullbackDirection == 1 and (inGoldenZone or inDeepZone) and not pullbackConfirmed
pullbackEntryShort = showPullbackZone and pullbackDirection == -1 and (inGoldenZone or inDeepZone) and not pullbackConfirmed


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ DASHBOARD â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showDashboard
    var string dashX = dashboardPosition == "Top Left" or dashboardPosition == "Bottom Left" ? position.top_left : position.top_right
    var string dashY = dashboardPosition == "Bottom Left" or dashboardPosition == "Bottom Right" ? position.bottom_left : dashX
    
    // Compact table - 7 rows instead of 11
    var table dashboard = table.new(dashY, 2, 7, border_width=1)
    
    // Structure state text
    stateText = structureState == 1 ? "BULL" : (structureState == -1 ? "BEAR" : "RANGE")
    stateColor = structureState == 1 ? bullColor : (structureState == -1 ? bearColor : neutralColor)
    
    // BOS strength
    bosStrengthText = lastBOSStrong ? "S" : "W"
    bosStrengthColor = lastBOSStrong ? strongBOSColor : weakBOSColor
    
    // Protected level display (shortened)
    var string protectedText = "-"
    if structureState == 1
        protectedText := str.tostring(protectedLow, format.mintick)
    else if structureState == -1
        protectedText := str.tostring(protectedHigh, format.mintick)
    else
        protectedText := "-"
    
    // Pullback Zone Status (shortened)
    var string pullbackStatus = "-"
    var color pullbackStatusColor = color.gray
    if pullbackDirection == 1
        if inGoldenZone
            pullbackStatus := "ZONEâ–²"
            pullbackStatusColor := color.lime
        else if pullbackConfirmed
            pullbackStatus := "GOâ–²"
            pullbackStatusColor := bullColor
        else
            pullbackStatus := "WAITâ–²"
            pullbackStatusColor := color.yellow
    else if pullbackDirection == -1
        if inGoldenZone
            pullbackStatus := "ZONEâ–¼"
            pullbackStatusColor := color.lime
        else if pullbackConfirmed
            pullbackStatus := "GOâ–¼"
            pullbackStatusColor := bearColor
        else
            pullbackStatus := "WAITâ–¼"
            pullbackStatusColor := color.yellow
    else
        pullbackStatus := "-"
        pullbackStatusColor := color.gray
    
    // Row 0: Structure state (header)
    table.cell(dashboard, 0, 0, stateText, text_color=stateColor, bgcolor=color.new(stateColor, 85), text_size=size.normal)
    table.cell(dashboard, 1, 0, timeframe.period + " | " + str.tostring(swingLength), text_color=color.orange, bgcolor=color.new(color.gray, 85), text_size=size.normal)
    
    // Row 1: Swing levels combined
    table.cell(dashboard, 0, 1, "H " + str.tostring(confirmedSwingHigh, format.mintick), text_color=bearColor, text_size=size.normal)
    table.cell(dashboard, 1, 1, "L " + str.tostring(confirmedSwingLow, format.mintick), text_color=bullColor, text_size=size.normal)
    
    // Row 2: Protected level
    table.cell(dashboard, 0, 2, "Prot", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 2, protectedText, text_color=stateColor, text_size=size.normal)
    
    // Row 3: BOS strength + bars since
    table.cell(dashboard, 0, 3, "BOS", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 3, bosStrengthText + " | " + str.tostring(barsSinceImpulse) + "b", text_color=bosStrengthColor, text_size=size.normal)
    
    // Row 4: Active zones
    activeZoneCount = array.size(activeZones)
    table.cell(dashboard, 0, 4, "S/D", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 4, str.tostring(activeZoneCount), text_color=color.white, text_size=size.normal)
    
    // Row 5: Pullback status
    table.cell(dashboard, 0, 5, "Entry", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 5, pullbackStatus, text_color=pullbackStatusColor, text_size=size.normal)
    
    // Row 6: Auto-TF indicator
    autoTFText = useAutoTF ? "Auto" : "Manual"
    table.cell(dashboard, 0, 6, "TF", text_color=color.gray, text_size=size.normal)
    table.cell(dashboard, 1, 6, autoTFText, text_color=useAutoTF ? color.green : color.gray, text_size=size.normal)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ ALERTS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// BOS Alerts (with strength)
alertcondition(bullishBOS and bosIsStrong, title="Strong Bullish BOS", message="Strong Bullish Break of Structure on {{ticker}} {{interval}}")
alertcondition(bullishBOS and not bosIsStrong, title="Weak Bullish BOS", message="Weak Bullish Break of Structure on {{ticker}} {{interval}}")
alertcondition(bearishBOS and bosIsStrong, title="Strong Bearish BOS", message="Strong Bearish Break of Structure on {{ticker}} {{interval}}")
alertcondition(bearishBOS and not bosIsStrong, title="Weak Bearish BOS", message="Weak Bearish Break of Structure on {{ticker}} {{interval}}")

// Standard BOS Alerts
alertcondition(bullishBOS, title="Bullish BOS", message="Bullish Break of Structure detected on {{ticker}} {{interval}}")
alertcondition(bearishBOS, title="Bearish BOS", message="Bearish Break of Structure detected on {{ticker}} {{interval}}")

// Structure Change Alerts
structureFlipped = structureState != prevStructureState and prevStructureState != 0
alertcondition(structureFlipped and structureState == 1, title="Structure Flip Bullish", message="Structure flipped from Bearish to Bullish on {{ticker}} {{interval}}")
alertcondition(structureFlipped and structureState == -1, title="Structure Flip Bearish", message="Structure flipped from Bullish to Bearish on {{ticker}} {{interval}}")
alertcondition(structureFlipped and structureState == 0, title="Entered Consolidation", message="Market entered consolidation on {{ticker}} {{interval}}")

// Protected Level Alerts
alertcondition(protectedLevelBroken and structureState == 1, title="Protected Low Broken", message="Protected Low broken - structure shift on {{ticker}} {{interval}}")
alertcondition(protectedLevelBroken and structureState == -1, title="Protected High Broken", message="Protected High broken - structure shift on {{ticker}} {{interval}}")

// Internal Break / Trap Alerts
alertcondition(internalBullBreak, title="Internal Bull Break (Trap Warning)", message="Internal bullish break detected - possible trap on {{ticker}} {{interval}}")
alertcondition(internalBearBreak, title="Internal Bear Break (Trap Warning)", message="Internal bearish break detected - possible trap on {{ticker}} {{interval}}")

// Liquidity Sweep Alerts
alertcondition(bullSweep, title="Bullish Sweep", message="Liquidity Sweep above swing high on {{ticker}} {{interval}}")
alertcondition(bearSweep, title="Bearish Sweep", message="Liquidity Sweep below swing low on {{ticker}} {{interval}}")

// Pullback Entry Alerts
alertcondition(pullbackEntryLong, title="Pullback Entry Long", message="Price in golden zone for LONG entry on {{ticker}} {{interval}}")
alertcondition(pullbackEntryShort, title="Pullback Entry Short", message="Price in golden zone for SHORT entry on {{ticker}} {{interval}}")
alertcondition(pullbackEntryLong and pullbackConfirmed, title="Confirmed Long Entry", message="CONFIRMED Long entry signal in golden zone on {{ticker}} {{interval}}")
alertcondition(pullbackEntryShort and pullbackConfirmed, title="Confirmed Short Entry", message="CONFIRMED Short entry signal in golden zone on {{ticker}} {{interval}}")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ PLOTS â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Background color based on structure (subtle)
bgColor = structureState == 1 ? color.new(bullColor, 97) : (structureState == -1 ? color.new(bearColor, 97) : color.new(neutralColor, 98))
bgcolor(bgColor, title="Structure Background")

// Plot swing levels as reference
plot(confirmedSwingHigh, "Swing High", color=color.new(bearColor, 70), style=plot.style_circles, linewidth=1, display=display.none)
plot(confirmedSwingLow, "Swing Low", color=color.new(bullColor, 70), style=plot.style_circles, linewidth=1, display=display.none)

// Plot protected levels for external use
plot(useProtectedLevels and structureState == 1 ? protectedLow : na, "Protected Low", color=color.new(bullColor, 50), style=plot.style_linebr, linewidth=1, display=display.none)
plot(useProtectedLevels and structureState == -1 ? protectedHigh : na, "Protected High", color=color.new(bearColor, 50), style=plot.style_linebr, linewidth=1, display=display.none)

// Plot impulse range for external use
plot(useInternalFilter ? impulseHigh : na, "Impulse High", color=color.new(color.purple, 70), style=plot.style_linebr, linewidth=1, display=display.none)
plot(useInternalFilter ? impulseLow : na, "Impulse Low", color=color.new(color.purple, 70), style=plot.style_linebr, linewidth=1, display=display.none)
